// Generated by dart2js, the Dart to JavaScript compiler version: 1.8.5.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart() {
  this.x = 0;
  delete this.x;
}
var A = new dart;
var B = new dart;
var C = new dart;
var D = new dart;
var E = new dart;
var F = new dart;
var G = new dart;
var H = new dart;
var J = new dart;
var K = new dart;
var L = new dart;
var M = new dart;
var N = new dart;
var O = new dart;
var P = new dart;
var Q = new dart;
var R = new dart;
var S = new dart;
var T = new dart;
var U = new dart;
var V = new dart;
var W = new dart;
var X = new dart;
var Y = new dart;
var Z = new dart;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = Object.create(null);

(function(reflectionData) {
  "use strict";
  function map(x) {
    x = Object.create(null);
    x.x = 0;
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["", "DeltaBlue.dart", , Z, {
  "^": "",
  main: function() {
    P.print("DeltaBlue(RunTime): " + H.S(new Z.DeltaBlue("DeltaBlue").measure$0()) + " us.");
  },
  chainTest: function(n) {
    var prev, first, last, i, v, t1, edit, plan, line;
    $.planner = new Z.Planner(0);
    for (prev = null, first = null, last = null, i = 0; i <= n; ++i, prev = v) {
      v = new Z.Variable([], null, 0, C.Strength_6_weakest, true, 0, "v");
      if (prev != null) {
        t1 = new Z.EqualityConstraint(prev, v, 1, C.Strength_0_required);
        t1.addToGraph$0();
        $.planner.incrementalAdd$1(t1);
      }
      if (i === 0)
        first = v;
      if (i === n)
        last = v;
    }
    t1 = new Z.StayConstraint(last, false, C.Strength_3_strongDefault);
    t1.addToGraph$0();
    $.planner.incrementalAdd$1(t1);
    edit = new Z.EditConstraint(first, false, C.Strength_2_preferred);
    edit.addToGraph$0();
    $.planner.incrementalAdd$1(edit);
    plan = $.planner.extractPlanFromConstraints$1([edit]);
    for (i = 0; i < 100; ++i) {
      first.value = i;
      plan.execute$0();
      if (last.value !== i) {
        H.printString("Chain test failed:");
        line = "Expected last value to be " + i + " but it was " + last.value + ".";
        H.printString(line);
      }
    }
  },
  projectionTest: function(n) {
    var scale, offset, dests, src, dst, i, t1;
    $.planner = new Z.Planner(0);
    scale = new Z.Variable([], null, 0, C.Strength_6_weakest, true, 10, "scale");
    offset = new Z.Variable([], null, 0, C.Strength_6_weakest, true, 1000, "offset");
    dests = [];
    for (src = null, dst = null, i = 0; i < n; ++i) {
      src = new Z.Variable([], null, 0, C.Strength_6_weakest, true, i, "src");
      dst = new Z.Variable([], null, 0, C.Strength_6_weakest, true, i, "dst");
      dests.push(dst);
      t1 = new Z.StayConstraint(src, false, C.Strength_4_normal);
      t1.addToGraph$0();
      $.planner.incrementalAdd$1(t1);
      t1 = new Z.ScaleConstraint(scale, offset, src, dst, 1, C.Strength_0_required);
      t1.addToGraph$0();
      $.planner.incrementalAdd$1(t1);
    }
    Z.change(src, 17);
    if (dst.value !== 1170)
      P.print("Projection 1 failed");
    Z.change(dst, 1050);
    if (src.value !== 5)
      P.print("Projection 2 failed");
    Z.change(scale, 5);
    for (t1 = n - 1, i = 0; i < t1; ++i) {
      if (i >= dests.length)
        return H.ioore(dests, i);
      if (dests[i].value !== i * 5 + 1000)
        H.printString("Projection 3 failed");
    }
    Z.change(offset, 2000);
    for (i = 0; i < t1; ++i) {
      if (i >= dests.length)
        return H.ioore(dests, i);
      if (dests[i].value !== i * 5 + 2000)
        H.printString("Projection 4 failed");
    }
  },
  change: function(v, newValue) {
    var edit, plan, i;
    edit = new Z.EditConstraint(v, false, C.Strength_2_preferred);
    edit.addToGraph$0();
    $.planner.incrementalAdd$1(edit);
    plan = $.planner.extractPlanFromConstraints$1([edit]);
    for (i = 0; i < 10; ++i) {
      v.value = newValue;
      plan.execute$0();
    }
    if (edit.isSatisfied$0())
      $.planner.incrementalRemove$1(edit);
    edit.removeFromGraph$0();
  },
  DeltaBlue: {
    "^": "BenchmarkBase;name",
    run$0: function() {
      Z.chainTest(100);
      Z.projectionTest(100);
    }
  },
  Strength: {
    "^": "Object;value,name"
  },
  Constraint: {
    "^": "Object;",
    satisfy$1: function(mark) {
      var out, overridden;
      this.chooseMethod$1(mark);
      if (!this.isSatisfied$0()) {
        if (this.strength === C.Strength_0_required)
          P.print("Could not satisfy a required constraint!");
        return;
      }
      this.markInputs$1(mark);
      out = this.output$0();
      overridden = out.determinedBy;
      if (overridden != null)
        overridden.markUnsatisfied$0();
      out.determinedBy = this;
      if (!$.planner.addPropagate$2(this, mark))
        P.print("Cycle encountered");
      out.mark = mark;
      return overridden;
    },
    isInput$0: function() {
      return false;
    }
  },
  UnaryConstraint: {
    "^": "Constraint;",
    addToGraph$0: function() {
      this.myOutput.constraints.push(this);
      this.satisfied = false;
    },
    chooseMethod$1: function(mark) {
      var t1 = this.myOutput;
      this.satisfied = t1.mark !== mark && this.strength.value < t1.walkStrength.value;
    },
    isSatisfied$0: function() {
      return this.satisfied;
    },
    markInputs$1: function(mark) {
    },
    output$0: function() {
      return this.myOutput;
    },
    recalculate$0: function() {
      var t1, t2;
      t1 = this.myOutput;
      t1.walkStrength = this.strength;
      t2 = !this.isInput$0();
      t1.stay = t2;
      if (t2)
        this.execute$0();
    },
    markUnsatisfied$0: function() {
      this.satisfied = false;
    },
    inputsKnown$1: function(mark) {
      return true;
    },
    removeFromGraph$0: function() {
      var t1 = this.myOutput;
      if (t1 != null)
        t1.removeConstraint$1(this);
      this.satisfied = false;
    }
  },
  StayConstraint: {
    "^": "UnaryConstraint;myOutput,satisfied,strength",
    execute$0: function() {
    }
  },
  EditConstraint: {
    "^": "UnaryConstraint;myOutput,satisfied,strength",
    isInput$0: function() {
      return true;
    },
    execute$0: function() {
    }
  },
  BinaryConstraint: {
    "^": "Constraint;",
    chooseMethod$1: function(mark) {
      var t1, t2, t3;
      t1 = this.v1;
      t2 = t1.mark;
      if (t2 === mark) {
        t3 = this.v2;
        this.direction = t3.mark !== mark && this.strength.value < t3.walkStrength.value ? 2 : 1;
      }
      t3 = this.v2;
      if (t3.mark === mark)
        this.direction = t2 !== mark && this.strength.value < t1.walkStrength.value ? 0 : 1;
      t1 = t1.walkStrength.value;
      t3 = t3.walkStrength.value;
      if (t1 > t3)
        this.direction = this.strength.value < t1 ? 0 : 1;
      else
        this.direction = this.strength.value < t3 ? 2 : 0;
    },
    addToGraph$0: function() {
      this.v1.constraints.push(this);
      this.v2.constraints.push(this);
      this.direction = 1;
    },
    isSatisfied$0: function() {
      return this.direction !== 1;
    },
    markInputs$1: function(mark) {
      (this.direction === 2 ? this.v1 : this.v2).mark = mark;
    },
    output$0: function() {
      return this.direction === 2 ? this.v2 : this.v1;
    },
    recalculate$0: function() {
      var t1, ihn, out, t2;
      t1 = this.direction === 2;
      ihn = t1 ? this.v1 : this.v2;
      out = t1 ? this.v2 : this.v1;
      t1 = this.strength;
      t2 = ihn.walkStrength;
      out.walkStrength = t1.value > t2.value ? t1 : t2;
      t1 = ihn.stay;
      out.stay = t1;
      if (t1)
        this.execute$0();
    },
    markUnsatisfied$0: function() {
      this.direction = 1;
    },
    inputsKnown$1: function(mark) {
      var i = this.direction === 2 ? this.v1 : this.v2;
      return i.mark === mark || i.stay || i.determinedBy == null;
    },
    removeFromGraph$0: function() {
      this.v1.removeConstraint$1(this);
      this.v2.removeConstraint$1(this);
      this.direction = 1;
    }
  },
  ScaleConstraint: {
    "^": "BinaryConstraint;scale,offset,v1,v2,direction,strength",
    addToGraph$0: function() {
      Z.BinaryConstraint.prototype.addToGraph$0.call(this);
      this.scale.constraints.push(this);
      this.offset.constraints.push(this);
    },
    removeFromGraph$0: function() {
      Z.BinaryConstraint.prototype.removeFromGraph$0.call(this);
      this.scale.removeConstraint$1(this);
      this.offset.removeConstraint$1(this);
    },
    markInputs$1: function(mark) {
      Z.BinaryConstraint.prototype.markInputs$1.call(this, mark);
      this.offset.mark = mark;
      this.scale.mark = mark;
    },
    execute$0: function() {
      var t1, t2, t3, t4;
      t1 = this.v2;
      t2 = this.v1;
      t3 = this.scale;
      t4 = this.offset;
      if (this.direction === 2)
        t1.value = t2.value * t3.value + t4.value;
      else
        t2.value = C.JSInt_methods.$tdiv(t1.value - t4.value, t3.value);
    },
    recalculate$0: function() {
      var t1, ihn, out, t2;
      t1 = this.direction === 2;
      ihn = t1 ? this.v1 : this.v2;
      out = t1 ? this.v2 : this.v1;
      t1 = this.strength;
      t2 = ihn.walkStrength;
      out.walkStrength = t1.value > t2.value ? t1 : t2;
      t1 = ihn.stay && this.scale.stay && this.offset.stay;
      out.stay = t1;
      if (t1)
        this.execute$0();
    }
  },
  EqualityConstraint: {
    "^": "BinaryConstraint;v1,v2,direction,strength",
    execute$0: function() {
      var t1, t2;
      t1 = this.direction === 2;
      t2 = t1 ? this.v2 : this.v1;
      t2.value = (t1 ? this.v1 : this.v2).value;
    }
  },
  Variable: {
    "^": "Object;constraints,determinedBy,mark,walkStrength,stay,value,name",
    removeConstraint$1: function(c) {
      C.JSArray_methods.remove$1(this.constraints, c);
      if (this.determinedBy === c)
        this.determinedBy = null;
    }
  },
  Planner: {
    "^": "Object;currentMark",
    incrementalAdd$1: function(c) {
      var t1, overridden;
      t1 = ++this.currentMark;
      for (overridden = c.satisfy$1(t1); overridden != null; overridden = overridden.satisfy$1(t1))
        ;
    },
    incrementalRemove$1: function(c) {
      var out, unsatisfied, strength, i, u, t1;
      out = c.output$0();
      c.markUnsatisfied$0();
      c.removeFromGraph$0();
      unsatisfied = this.removePropagateFrom$1(out);
      strength = C.Strength_0_required;
      do {
        for (i = 0; i < unsatisfied.length; ++i) {
          u = unsatisfied[i];
          if (u.strength === strength)
            this.incrementalAdd$1(u);
        }
        t1 = strength.value;
        if (t1 >= 6)
          return H.ioore(C.List_2fg, t1);
        strength = C.List_2fg[t1];
      } while (strength !== C.Strength_6_weakest);
    },
    makePlan$1: function(sources) {
      var t1, t2, c;
      t1 = ++this.currentMark;
      t2 = [];
      for (; sources.length > 0;) {
        c = sources.pop();
        if (c.output$0().mark !== t1 && c.inputsKnown$1(t1)) {
          t2.push(c);
          c.output$0().mark = t1;
          this.addConstraintsConsumingTo$2(c.output$0(), sources);
        }
      }
      return new Z.Plan(t2);
    },
    extractPlanFromConstraints$1: function(constraints) {
      var sources, i, c;
      sources = [];
      for (i = 0; i < 1; ++i) {
        c = constraints[i];
        if (c.satisfied)
          sources.push(c);
      }
      return this.makePlan$1(sources);
    },
    addPropagate$2: function(c, mark) {
      var todo, d;
      todo = [c];
      for (; todo.length > 0;) {
        d = todo.pop();
        if (d.output$0().mark === mark) {
          this.incrementalRemove$1(c);
          return false;
        }
        d.recalculate$0();
        this.addConstraintsConsumingTo$2(d.output$0(), todo);
      }
      return true;
    },
    removePropagateFrom$1: function(out) {
      var unsatisfied, todo, v, t1, i, c, determining, next;
      out.determinedBy = null;
      out.walkStrength = C.Strength_6_weakest;
      out.stay = true;
      unsatisfied = [];
      todo = [out];
      for (; todo.length > 0;) {
        v = todo.pop();
        for (t1 = v.constraints, i = 0; i < t1.length; ++i) {
          c = t1[i];
          if (!c.isSatisfied$0())
            unsatisfied.push(c);
        }
        determining = v.determinedBy;
        for (i = 0; i < t1.length; ++i) {
          next = t1[i];
          if (next !== determining && next.isSatisfied$0()) {
            next.recalculate$0();
            todo.push(next.output$0());
          }
        }
      }
      return unsatisfied;
    },
    addConstraintsConsumingTo$2: function(v, coll) {
      var determining, t1, i, c;
      determining = v.determinedBy;
      for (t1 = v.constraints, i = 0; i < t1.length; ++i) {
        c = t1[i];
        if (c !== determining && c.isSatisfied$0())
          coll.push(c);
      }
    }
  },
  Plan: {
    "^": "Object;list",
    execute$0: function() {
      var t1, i;
      for (t1 = this.list, i = 0; i < t1.length; ++i)
        t1[i].execute$0();
    }
  }
},
1],
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    }
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isbool: true
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return false;
    },
    toString$0: function(receiver) {
      return "null";
    }
  },
  JSArray: {
    "^": "Interceptor;",
    checkGrowable$1: function(receiver, reason) {
      if (!!receiver.fixed$length)
        throw H.wrapException(P.UnsupportedError$(reason));
    },
    remove$1: function(receiver, element) {
      var i;
      this.checkGrowable$1(receiver, "remove");
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isJSArray: true
  },
  JSNumber: {
    "^": "Interceptor;",
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    $add: function(receiver, other) {
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    $isnum: true
  },
  JSString: {
    "^": "Interceptor;",
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    substring$2: function(receiver, startIndex, endIndex) {
      H.checkInt(startIndex);
      if (endIndex == null)
        endIndex = receiver.length;
      H.checkInt(endIndex);
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isString: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled, t1;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1)
      t1 = $name.charCodeAt(0) === 36;
    else
      t1 = false;
    if (t1)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_dateNow: [function() {
    return Date.now();
  }, "call$0", "Primitives_dateNow$closure", 0, 0, 0],
  Primitives_initTicker: function() {
    var $window, performance;
    if ($.Primitives_timerFrequency != null)
      return;
    $.Primitives_timerFrequency = 1000;
    $.Primitives_timerTicks = H.Primitives_dateNow$closure();
    if (typeof window == "undefined")
      return;
    $window = window;
    if ($window == null)
      return;
    performance = $window.performance;
    if (performance == null)
      return;
    if (typeof performance.now != "function")
      return;
    $.Primitives_timerFrequency = 1000000;
    $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$as(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index, null, null));
  },
  checkInt: function(value) {
    return value;
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = Array;
    reflectionInfo.fixed$length = Array;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = Array;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  Primitives_initTicker_closure: {
    "^": "Closure;performance_0",
    call$0: function() {
      return C.JSNumber_methods.toInt$0(Math.floor(1000 * this.performance_0.now()));
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,_name",
    $eq: function(_, other) {
      return false;
    },
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = Array;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + this.message;
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  }
}],
["benchmark_base", "../../common/dart/BenchmarkBase.dart", , V, {
  "^": "",
  BenchmarkBase_measureFor: function(f, timeMinimum) {
    var watch, iter, elapsed, t1, t2;
    watch = new P.Stopwatch(null, null);
    H.Primitives_initTicker();
    $.Stopwatch__frequency = $.Primitives_timerFrequency;
    watch.start$0();
    for (iter = 0, elapsed = 0; elapsed < timeMinimum;) {
      f.call$0();
      t1 = watch.get$elapsedTicks();
      t2 = $.Stopwatch__frequency;
      if (typeof t2 !== "number")
        return H.iae(t2);
      elapsed = C.JSNumber_methods.$tdiv(t1 * 1000, t2);
      ++iter;
    }
    return 1000 * elapsed / iter;
  },
  BenchmarkBase: {
    "^": "Object;",
    run$0: function() {
    },
    exercise$0: function() {
      for (var i = 0; i < 10; ++i)
        this.run$0();
    },
    measure$0: function() {
      V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure(this), 100);
      return V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure0(this), 2000);
    }
  },
  BenchmarkBase_measure_closure: {
    "^": "Closure;this_0",
    call$0: function() {
      this.this_0.run$0();
    }
  },
  BenchmarkBase_measure_closure0: {
    "^": "Closure;this_1",
    call$0: function() {
      this.this_1.exercise$0();
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  ListIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this._iterable;
      $length = t1.length;
      if (this._length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this._index;
      if (t2 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t1[t2];
      this._index = t2 + 1;
      return true;
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = P.StringBuffer$(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    buffer.write$1(rightDelimiter);
    t1 = buffer.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i)
      if (o === t1[i])
        return true;
    return false;
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  Error_safeToString: function(object) {
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string")
      return JSON.stringify(object);
    return H.Primitives_objectToString(object);
  },
  print: function(object) {
    H.printString(object);
  },
  bool: {
    "^": "Object;",
    toString$0: function(_) {
      return this ? "true" : "false";
    },
    $isbool: true
  },
  "+bool": 0,
  $double: {
    "^": "num;"
  },
  "+double": 0,
  Error: {
    "^": "Object;"
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;_hasValue,invalidValue,name,message",
    toString$0: function(_) {
      var t1;
      if (!this._hasValue) {
        t1 = this.message;
        return t1 != null ? "Invalid arguments(s): " + H.S(t1) : "Invalid arguments(s)";
      }
      return H.S(this.message) + ": " + H.S(P.Error_safeToString(this.invalidValue));
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(false, null, null, message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;start,end,_hasValue,invalidValue,name,message",
    toString$0: function(_) {
      var value;
      if (!this._hasValue)
        return "RangeError: " + H.S(this.message);
      value = P.Error_safeToString(this.invalidValue);
      return "RangeError: " + H.S(this.message) + " (" + H.S(value) + ")";
    },
    static: {RangeError$value: function(value, $name, message) {
        return new P.RangeError(null, null, true, value, $name, "Value not in range");
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(this.modifiedObject)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  List: {
    "^": "Object;"
  },
  "+List": 0,
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Stopwatch: {
    "^": "Object;_start,_stop",
    start$0: function() {
      var t1, t2;
      t1 = this._start == null;
      if (!t1 && true)
        return;
      t2 = $.Primitives_timerTicks;
      if (t1)
        this._start = t2.call$0();
      else {
        t1 = t2.call$0();
        t2 = C.JSNull_methods.$sub(this._stop, this._start);
        if (typeof t1 !== "number")
          return t1.$sub();
        this._start = C.JSNumber_methods.$sub(t1, t2);
        this._stop = null;
      }
    },
    get$elapsedTicks: function() {
      var t1, t2;
      if (this._start == null)
        return 0;
      t1 = $.Primitives_timerTicks.call$0();
      t2 = this._start;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 - t2;
      t1 = t2;
      return t1;
    },
    static: {"^": "Stopwatch__frequency"}
  },
  String: {
    "^": "Object;",
    $isString: true
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = new H.ListIterator(objects, objects.length, 0, null);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do {
          str = iterator._current;
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      } else {
        this.write$1(iterator._current);
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator._current;
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  return receiver;
};
J.getInterceptor$as = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  return receiver;
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.get$length$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$length(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
Isolate.makeConstantList = function(list) {
  list.immutable$list = Array;
  list.fixed$length = Array;
  return list;
};
;
C.JSArray_methods = J.JSArray.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.Strength_1_strongPreferred = new Z.Strength(1, "strongPreferred");
C.Strength_2_preferred = new Z.Strength(2, "preferred");
C.Strength_3_strongDefault = new Z.Strength(3, "strongDefault");
C.Strength_4_normal = new Z.Strength(4, "normal");
C.Strength_5_weakDefault = new Z.Strength(5, "weakDefault");
C.Strength_6_weakest = new Z.Strength(6, "weakest");
C.List_2fg = Isolate.makeConstantList([C.Strength_1_strongPreferred, C.Strength_2_preferred, C.Strength_3_strongDefault, C.Strength_4_normal, C.Strength_5_weakDefault, C.Strength_6_weakest]);
C.Strength_0_required = new Z.Strength(0, "required");
init.isHunkLoaded = function(hunkHash) {
  return !!$dart_deferred_initializers[hunkHash];
};
init.initializeLoadedHunk = function(hunkHash) {
  $dart_deferred_initializers[hunkHash](globalsHolder, $);
};
init.deferredLibraryUris = {};
init.deferredLibraryHashes = {};
$.planner = null;
$.Primitives_timerFrequency = null;
$.Primitives_timerTicks = null;
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.printToZone = null;
$.Stopwatch__frequency = null;
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});

init.metadata = [{func: "num_", ret: P.num},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = Object.create(null);
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties) {
        if (hasOwnProperty.call(properties, member)) {
          object[member] = properties[member];
        }
      }
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = Object.create(null);
    var allClasses = init.allClasses;
    var constructors;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      var desc = collectedClasses[cls];
      if (desc instanceof Array)
        desc = desc[1];
      var classData = desc["^"], supr, name = cls, fields = classData;
      if (typeof classData == "string") {
        var split = classData.split("/");
        if (split.length == 2) {
          name = split[0];
          fields = split[1];
        }
      }
      var s = fields.split(";");
      fields = s[1] == "" ? [] : s[1].split(",");
      supr = s[0];
      split = supr.split(":");
      if (split.length == 2) {
        supr = split[0];
        var functionSignature = split[1];
        if (functionSignature)
          desc.$signature = function(s) {
            return function() {
              return init.metadata[s];
            };
          }(functionSignature);
      }
      if (typeof dart_precompiled != "function") {
        combinedConstructorFunction += defineClass(name, cls, fields);
        constructorsList.push(cls);
      }
      if (supr)
        pendingClasses[cls] = supr;
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = init.finishedClasses;
    function finishClass(cls) {
      if (finishedClasses[cls])
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  (function() {
    init.allClasses = Object.create(null);
    init.interceptorsByTag = Object.create(null);
    init.leafTags = Object.create(null);
    init.finishedClasses = Object.create(null);
  })();
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    if (!init.lazies)
      init.lazies = Object.create(null);
    init.lazies[fieldName] = getterName;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      var lazies = init.lazies;
      for (var lazyInit in lazies) {
        this[lazies[lazyInit]] = null;
      }
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
      for (var lazyInit in lazies) {
        var lazyInitName = lazies[lazyInit];
        this[lazyInitName] = isolateProperties[lazyInitName];
      }
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
// BEGIN invoke [main].
;(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function") {
    dartMainRunner(Z.main, []);
  } else {
    Z.main([]);
  }
});
;
// END invoke [main].
})()

//# sourceMappingURL=DeltaBlue.dart.js.map
