// Generated by dart2js, the Dart to JavaScript compiler version: 1.9.1.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferered library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
(function($) {
function map(x) {
  x = Object.create(null);
  x.x = 0;
  delete x.x;
  return x;
}
var A = map();
var B = map();
var C = map();
var D = map();
var E = map();
var F = map();
var G = map();
var H = map();
var J = map();
var K = map();
var L = map();
var M = map();
var N = map();
var O = map();
var P = map();
var Q = map();
var R = map();
var S = map();
var T = map();
var U = map();
var V = map();
var W = map();
var X = map();
var Y = map();
var Z = map();
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
$.functionThatReturnsNull = function() {
};
;
function parseReflectionData(reflectionData) {
  "use strict";
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  function defineClass(name, fields) {
    var accessors = [];
    var str = "function " + name + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, name);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += name + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + name + ";\n";
    str += "if($desc instanceof Array) $desc = \$desc[1];\n";
    str += name + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string")
      str += name + ".name=\"" + name + "\";\n";
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    return function(constructor, superConstructor) {
      if (superConstructor == null) {
        var prototype = constructor.prototype;
        prototype.constructor = constructor;
        prototype.$isObject = constructor;
        return prototype;
      }
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      var members = Object.keys(properties);
      for (var i = 0; i < members.length; i++) {
        var member = members[i];
        object[member] = properties[member];
      }
      object["$is" + constructor.name] = constructor;
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  function finishClasses(processedClasses) {
    var allClasses = init.allClasses;
    processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
    var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
    processedClasses.combinedConstructorFunction = null;
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = processedClasses.collected[cls];
      var globalObject = $;
      if (desc instanceof Array) {
        globalObject = desc[0] || $;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = init.finishedClasses;
    function finishClass(cls) {
      if (finishedClasses[cls])
        return;
      finishedClasses[cls] = true;
      var superclass = processedClasses.pending[cls];
      if (!superclass || typeof superclass != "string") {
        inheritFrom(allClasses[cls], null);
        return;
      }
      finishClass(superclass);
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var constructor = allClasses[cls];
      var prototype = inheritFrom(constructor, superConstructor);
    }
    var properties = Object.keys(processedClasses.pending);
    for (var i = 0; i < properties.length; i++)
      finishClass(properties[i]);
  }
  function processClassData(cls, descriptor, processedClasses) {
    var newDesc = {};
    var previousProperty;
    var properties = Object.keys(descriptor);
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      var firstChar = property.substring(0, 1);
      if (property === "static")
        processStatics(init.statics[cls] = descriptor[property], processedClasses);
      else if (firstChar === "+") {
        mangledNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
      } else if (firstChar === "*") {
        newDesc[previousProperty].$defaultValues = descriptor[property];
        var optionalMethods = newDesc.$methodsWithOptionalArguments;
        if (!optionalMethods)
          newDesc.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else {
        var elem = descriptor[property];
        if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
          addStubs(newDesc, elem, property, false, descriptor, []);
        else
          newDesc[previousProperty = property] = elem;
      }
    }
    var classData = newDesc["^"], split, supr, fields = classData;
    var s = fields.split(";");
    fields = s[1] == "" ? [] : s[1].split(",");
    supr = s[0];
    split = supr.split(":");
    if (split.length == 2) {
      supr = split[0];
      var functionSignature = split[1];
      if (functionSignature)
        newDesc.$signature = function(s) {
          return function() {
            return init.metadata[s];
          };
        }(functionSignature);
    }
    if (supr)
      processedClasses.pending[cls] = supr;
    processedClasses.combinedConstructorFunction += defineClass(cls, fields);
    processedClasses.constructorsList.push(cls);
    processedClasses.collected[cls] = [globalObject, newDesc];
    classes.push(cls);
  }
  function processStatics(descriptor, processedClasses) {
    var properties = Object.keys(descriptor);
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods)
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array)
        addStubs(globalObject, element, property, true, descriptor, functions);
      else {
        previousProperty = property;
        processClassData(property, element, processedClasses);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var index = 0, alias = array[index], f;
    if (typeof alias == "string")
      f = array[++index];
    else {
      f = alias;
      alias = name;
    }
    var funcs = [originalDescriptor[name] = descriptor[name] = descriptor[alias] = f];
    f.$stubName = name;
    functions.push(name);
    for (; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++)
      funcs[i].$callName = array[index + 1];
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
    }
  }
  function tearOffGetter(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  var processedClasses = Object.create(null);
  processedClasses.collected = Object.create(null);
  processedClasses.pending = Object.create(null);
  processedClasses.constructorsList = [];
  processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor, processedClasses);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
  finishClasses(processedClasses);
}
var dart = [
["", "Havlak.dart", , A, {
  "^": "",
  main: function() {
    var t1, score, line;
    t1 = A.Havlak$();
    score = t1.measure$0();
    line = t1.name + "(RunTime): " + H.S(score) + " us.";
    H.printString(line);
  },
  buildDiamond: function(cfg, start) {
    var t1, t2, t3;
    t1 = start + 1;
    A.BasicBlockEdge$(cfg, start, t1);
    t2 = start + 2;
    A.BasicBlockEdge$(cfg, start, t2);
    t3 = start + 3;
    A.BasicBlockEdge$(cfg, t1, t3);
    A.BasicBlockEdge$(cfg, t2, t3);
    return t3;
  },
  buildStraight: function(cfg, start, n) {
    var t1, i, t2, t3, t4;
    for (t1 = cfg.edgeList, i = 0; i < n; ++i) {
      t2 = start + i;
      t3 = new A.BasicBlockEdge(null, null);
      t4 = cfg.createNode$1(t2);
      t3.from = t4;
      t2 = cfg.createNode$1(t2 + 1);
      t3.to = t2;
      t4.addOutEdge$1(t2);
      t2.addInEdge$1(t4);
      t1.push(t3);
    }
    return start + n;
  },
  buildBaseLoop: function(cfg, from) {
    var header, diamond1, d11, diamond2, footer, t1, t2, t3, t4;
    header = A.buildStraight(cfg, from, 1);
    diamond1 = A.buildDiamond(cfg, header);
    d11 = A.buildStraight(cfg, diamond1, 1);
    diamond2 = A.buildDiamond(cfg, d11);
    footer = A.buildStraight(cfg, diamond2, 1);
    t1 = new A.BasicBlockEdge(null, null);
    t2 = cfg.createNode$1(diamond2);
    t1.from = t2;
    t3 = cfg.createNode$1(d11);
    t1.to = t3;
    t2.addOutEdge$1(t3);
    t3.addInEdge$1(t2);
    t2 = cfg.edgeList;
    t2.push(t1);
    t1 = new A.BasicBlockEdge(null, null);
    t3 = cfg.createNode$1(diamond1);
    t1.from = t3;
    t4 = cfg.createNode$1(header);
    t1.to = t4;
    t3.addOutEdge$1(t4);
    t4.addInEdge$1(t3);
    t2.push(t1);
    t1 = new A.BasicBlockEdge(null, null);
    t3 = cfg.createNode$1(footer);
    t1.from = t3;
    t4 = cfg.createNode$1(from);
    t1.to = t4;
    t3.addOutEdge$1(t4);
    t4.addInEdge$1(t3);
    t2.push(t1);
    return A.buildStraight(cfg, footer, 1);
  },
  BasicBlock: {
    "^": "Object;name<,inEdges,outEdges<",
    toString$0: function(_) {
      return "BB" + this.name;
    },
    getNumPred$0: function() {
      return this.inEdges.length;
    },
    addInEdge$1: function(bb) {
      return this.inEdges.push(bb);
    },
    addOutEdge$1: function(bb) {
      return this.outEdges.push(bb);
    }
  },
  BasicBlockEdge: {
    "^": "Object;from,to",
    BasicBlockEdge$3: function(cfg, fromName, toName) {
      var t1;
      this.from = cfg.createNode$1(fromName);
      t1 = cfg.createNode$1(toName);
      this.to = t1;
      this.from.addOutEdge$1(t1);
      this.to.addInEdge$1(this.from);
      cfg.edgeList.push(this);
    },
    static: {BasicBlockEdge$: function(cfg, fromName, toName) {
        var t1 = new A.BasicBlockEdge(null, null);
        t1.BasicBlockEdge$3(cfg, fromName, toName);
        return t1;
      }}
  },
  CFG: {
    "^": "Object;basicBlockMap,edgeList,startNode",
    createNode$1: function($name) {
      var t1, node;
      t1 = this.basicBlockMap;
      node = t1.$index(0, $name);
      if (node == null) {
        node = new A.BasicBlock($name, [], []);
        $.numBasicBlocks = $.numBasicBlocks + 1;
        t1.$indexSet(0, $name, node);
      }
      if (t1._length === 1)
        this.startNode = node;
      return node;
    }
  },
  SimpleLoop: {
    "^": "Object;basicBlocks,children,counter,parent,header,isRoot,isReducible,nestingLevel,depthLevel",
    setNestingLevel$1: function(level) {
      this.nestingLevel = level;
      if (level === 0)
        this.isRoot = true;
    },
    checksum$0: function() {
      var t1, result, t2;
      t1 = {};
      result = this.counter;
      t1.result_0 = result;
      t2 = this.isRoot ? 1 : 0;
      result = ((result & 268435455) << 1 >>> 0) + t2;
      t1.result_0 = result;
      t2 = this.isReducible ? 1 : 0;
      result = ((result & 268435455) << 1 >>> 0) + t2;
      t1.result_0 = result;
      result = ((result & 268435455) << 1 >>> 0) + this.nestingLevel;
      t1.result_0 = result;
      result = ((result & 268435455) << 1 >>> 0) + this.depthLevel;
      t1.result_0 = result;
      t2 = this.header;
      if (t2 != null) {
        t2 = t2.get$name();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.result_0 = ((result & 268435455) << 1 >>> 0) + t2;
      }
      C.JSArray_methods.forEach$1(this.basicBlocks, new A.SimpleLoop_checksum_closure(t1));
      C.JSArray_methods.forEach$1(this.children, new A.SimpleLoop_checksum_closure0(t1));
      return t1.result_0;
    }
  },
  SimpleLoop_checksum_closure: {
    "^": "Closure;box_0",
    call$1: function(e) {
      var t1, t2, t3, result;
      t1 = this.box_0;
      t2 = t1.result_0;
      t3 = e.get$name();
      if (typeof t3 !== "number")
        return H.iae(t3);
      result = ((t2 & 268435455) << 1 >>> 0) + t3;
      t1.result_0 = result;
      return result;
    }
  },
  SimpleLoop_checksum_closure0: {
    "^": "Closure;box_0",
    call$1: function(e) {
      var t1, result;
      t1 = this.box_0;
      result = ((t1.result_0 & 268435455) << 1 >>> 0) + e.checksum$0();
      t1.result_0 = result;
      return result;
    }
  },
  LSG: {
    "^": "Object;loopCounter,loops,root",
    checksum$0: function() {
      var t1, t2;
      t1 = {};
      t2 = this.loops;
      t1.result_0 = t2.length;
      C.JSArray_methods.forEach$1(t2, new A.LSG_checksum_closure(t1));
      return ((t1.result_0 & 268435455) << 1 >>> 0) + this.root.checksum$0();
    }
  },
  LSG_checksum_closure: {
    "^": "Closure;box_0",
    call$1: function(e) {
      var t1, result;
      t1 = this.box_0;
      result = ((t1.result_0 & 268435455) << 1 >>> 0) + e.checksum$0();
      t1.result_0 = result;
      return result;
    }
  },
  UnionFindNode: {
    "^": "Object;dfsNumber<,parent,bb,loop",
    findSet$0: function() {
      var nodeList, node, t1, t2, iter;
      nodeList = [];
      for (node = this; t1 = node.parent, node !== t1;) {
        t2 = t1.parent;
        if (t1 == null ? t2 != null : t1 !== t2)
          nodeList.push(node);
        node = node.parent;
      }
      for (iter = 0; iter < nodeList.length; ++iter)
        nodeList[iter].parent = node.parent;
      return node;
    }
  },
  HavlakLoopFinder: {
    "^": "Object;cfg,lsg",
    DFS$5: function(currentNode, nodes, number, last, current) {
      var t1, t2, lastid, target, t3;
      if (current >= nodes.length)
        return H.ioore(nodes, current);
      t1 = nodes[current];
      t1.parent = t1;
      t1.bb = currentNode;
      t1.dfsNumber = current;
      t1 = currentNode.get$name();
      t2 = number.length;
      if (t1 >>> 0 !== t1 || t1 >= t2)
        return H.ioore(number, t1);
      number[t1] = current;
      for (lastid = current, target = 0; target < currentNode.get$outEdges().length; ++target) {
        t1 = currentNode.outEdges;
        if (target >= t1.length)
          return H.ioore(t1, target);
        t3 = t1[target].get$name();
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(number, t3);
        if (number[t3] === -1) {
          if (target >= t1.length)
            return H.ioore(t1, target);
          lastid = this.DFS$5(t1[target], nodes, number, last, lastid + 1);
        }
      }
      t1 = currentNode.name;
      if (t1 >= t2)
        return H.ioore(number, t1);
      t1 = number[t1];
      if (t1 >>> 0 !== t1 || t1 >= last.length)
        return H.ioore(last, t1);
      last[t1] = lastid;
      return lastid;
    },
    findLoops$0: function() {
      var t1, t2, size, nonBackPreds, backPreds, number, header, types, last, nodes, i, w, nodeW, nv, v, nodePool, vi, t3, workList, n, x, iter, ydash, t4, loop, np, node, t5;
      t1 = this.cfg;
      t2 = t1.startNode;
      if (t2 == null)
        return 0;
      size = t1.basicBlockMap._length;
      nonBackPreds = Array(size);
      backPreds = Array(size);
      number = Array(size);
      header = Array(size);
      types = Array(size);
      last = Array(size);
      nodes = Array(size);
      for (i = 0; i < size; ++i) {
        nonBackPreds[i] = [];
        backPreds[i] = [];
        number[i] = -1;
        header[i] = 0;
        types[i] = 1;
        last[i] = 0;
        nodes[i] = new A.UnionFindNode(0, null, null, null);
      }
      this.DFS$5(t2, nodes, number, last, 0);
      for (w = 0; w < size; ++w) {
        nodeW = nodes[w].bb;
        if (nodeW == null)
          types[w] = 5;
        else if (nodeW.getNumPred$0() > 0)
          for (t1 = nodeW.inEdges, nv = 0; nv < t1.length; ++nv) {
            t2 = t1[nv].get$name();
            if (t2 >>> 0 !== t2 || t2 >= size)
              return H.ioore(number, t2);
            v = number[t2];
            if (v !== -1) {
              if (typeof v !== "number")
                return H.iae(v);
              if (w <= v) {
                if (w >= size)
                  return H.ioore(last, w);
                t2 = last[w];
                if (typeof t2 !== "number")
                  return H.iae(t2);
                t2 = v <= t2;
              } else
                t2 = false;
              if (t2)
                backPreds[w].push(v);
              else
                nonBackPreds[w].push(v);
            }
          }
      }
      for (w = size - 1, t1 = this.lsg, t2 = t1.loops; w >= 0; --w) {
        nodePool = [];
        nodeW = nodes[w].bb;
        if (nodeW == null)
          continue;
        for (vi = 0; t3 = backPreds[w], vi < t3.length; ++vi) {
          v = t3[vi];
          if (v !== w) {
            if (v >>> 0 !== v || v >= size)
              return H.ioore(nodes, v);
            nodePool.push(nodes[v].findSet$0());
          } else
            types[w] = 3;
        }
        workList = [];
        for (n = 0; t3 = nodePool.length, n < t3; ++n)
          workList.push(nodePool[n]);
        if (t3 !== 0)
          types[w] = 2;
        for (; workList.length > 0;) {
          x = workList.splice(0, 1)[0];
          t3 = x.get$dfsNumber();
          if (t3 >= size)
            return H.ioore(nonBackPreds, t3);
          if (nonBackPreds[t3].length > 32768)
            return 0;
          iter = 0;
          while (true) {
            t3 = x.dfsNumber;
            if (t3 >= size)
              return H.ioore(nonBackPreds, t3);
            t3 = nonBackPreds[t3];
            if (!(iter < t3.length))
              break;
            t3 = t3[iter];
            if (t3 >>> 0 !== t3 || t3 >= size)
              return H.ioore(nodes, t3);
            ydash = nodes[t3].findSet$0();
            t3 = ydash.dfsNumber;
            if (w <= t3) {
              if (w >= size)
                return H.ioore(last, w);
              t4 = last[w];
              if (typeof t4 !== "number")
                return H.iae(t4);
              t4 = t3 <= t4;
            } else
              t4 = false;
            if (!t4) {
              types[w] = 4;
              nonBackPreds[w].push(t3);
            } else if (t3 !== w)
              if (C.JSArray_methods.indexOf$1(nodePool, ydash) === -1) {
                workList.push(ydash);
                nodePool.push(ydash);
              }
            ++iter;
          }
        }
        if (nodePool.length > 0 || types[w] === 3) {
          t3 = [];
          t4 = [];
          loop = new A.SimpleLoop(t3, t4, t1.loopCounter++, null, null, false, true, 0, 0);
          t3.push(nodeW);
          loop.header = nodeW;
          if (types[w] === 4)
            loop.isReducible = true;
          else
            loop.isReducible = false;
          nodes[w].loop = loop;
          for (np = 0; np < nodePool.length; ++np) {
            node = nodePool[np];
            t5 = node.dfsNumber;
            if (t5 >= size)
              return H.ioore(header, t5);
            header[t5] = w;
            node.parent = nodes[w];
            t5 = node.loop;
            if (t5 != null) {
              t5.parent = loop;
              t4.push(t5);
            } else
              t3.push(node.bb);
          }
          t2.push(loop);
        }
      }
      return t2.length;
    }
  },
  Havlak: {
    "^": "BenchmarkBase;cfg,name",
    exercise$0: function() {
      var t1, t2, numLoops;
      t1 = [];
      t2 = new A.SimpleLoop([], [], 0, null, null, false, true, 0, 0);
      t2.setNestingLevel$1(0);
      t1.push(t2);
      numLoops = new A.HavlakLoopFinder(this.cfg, new A.LSG(1, t1, t2)).findLoops$0();
      if (numLoops !== 1522)
        throw H.wrapException("Wrong result - expected <1522>, but was <" + numLoops + ">");
    },
    warmup$0: function() {
      var t1, dummyloop, t2, t3, lsg, checksum;
      for (t1 = this.cfg, dummyloop = 0; dummyloop < 20; ++dummyloop) {
        t2 = [];
        t3 = new A.SimpleLoop([], [], 0, null, null, false, true, 0, 0);
        lsg = new A.LSG(1, t2, t3);
        t3.nestingLevel = 0;
        t3.isRoot = true;
        t2.push(t3);
        new A.HavlakLoopFinder(t1, lsg).findLoops$0();
        checksum = lsg.checksum$0();
        if (checksum !== 435630002)
          throw H.wrapException("Wrong checksum - expected <435630002>, but was <" + H.S(checksum) + ">");
      }
    },
    Havlak$0: function() {
      var t1, t2, n, parlooptrees, n0, t3, t4, t5, i, j, bottom;
      t1 = this.cfg;
      t1.createNode$1(0);
      A.buildBaseLoop(t1, 0);
      t1.createNode$1(1);
      A.BasicBlockEdge$(t1, 0, 2);
      for (t2 = t1.edgeList, n = 2, parlooptrees = 0; parlooptrees < 10; ++parlooptrees) {
        n0 = n + 1;
        t1.createNode$1(n0);
        t3 = new A.BasicBlockEdge(null, null);
        t4 = t1.createNode$1(n);
        t3.from = t4;
        t5 = t1.createNode$1(n0);
        t3.to = t5;
        t4.addOutEdge$1(t5);
        t5.addInEdge$1(t4);
        t2.push(t3);
        for (n = n0, i = 0; i < 2; ++i, n = bottom) {
          n0 = A.buildStraight(t1, n, 1);
          for (j = 0; j < 25; ++j)
            n0 = A.buildBaseLoop(t1, n0);
          bottom = A.buildStraight(t1, n0, 1);
          t3 = new A.BasicBlockEdge(null, null);
          t4 = t1.createNode$1(n0);
          t3.from = t4;
          t5 = t1.createNode$1(n);
          t3.to = t5;
          t4.addOutEdge$1(t5);
          t5.addInEdge$1(t4);
          t2.push(t3);
        }
      }
    },
    static: {Havlak$: function() {
        var t1 = new A.Havlak(new A.CFG(P.HashMap_HashMap(null, null, null, null, null), [], null), "Havlak");
        t1.Havlak$0();
        return t1;
      }}
  }
},
1],
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    }
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    $isbool: 1
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    }
  },
  JSArray: {
    "^": "Interceptor;",
    forEach$1: function(receiver, f) {
      var end, i;
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        f.call$1(receiver[i]);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    indexOf$2: function(receiver, element, start) {
      var i;
      if (start >= receiver.length)
        return -1;
      for (i = start; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element))
          return i;
      return -1;
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isList: 1
  },
  ArrayIterator: {
    "^": "Object;_iterable,__interceptors$_length,_index,_current",
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this._iterable;
      $length = t1.length;
      if (this.__interceptors$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this._index;
      if (t2 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t1[t2];
      this._index = t2 + 1;
      return true;
    }
  },
  JSNumber: {
    "^": "Interceptor;",
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$("" + receiver));
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    $isnum: 1
  },
  JSInt: {
    "^": "JSNumber;",
    $isnum: 1,
    $is$int: 1
  },
  JSDouble: {
    "^": "JSNumber;",
    $isnum: 1
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver.charCodeAt(index);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    substring$2: function(receiver, startIndex, endIndex) {
      H.checkInt(startIndex);
      if (endIndex == null)
        endIndex = receiver.length;
      H.checkInt(endIndex);
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isString: 1
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_dateNow: [function() {
    return Date.now();
  }, "call$0", "Primitives_dateNow$closure", 0, 0, 0],
  Primitives_initTicker: function() {
    var $window, performance;
    if ($.Primitives_timerFrequency != null)
      return;
    $.Primitives_timerFrequency = 1000;
    $.Primitives_timerTicks = H.Primitives_dateNow$closure();
    if (typeof window == "undefined")
      return;
    $window = window;
    if ($window == null)
      return;
    performance = $window.performance;
    if (performance == null)
      return;
    if (typeof performance.now != "function")
      return;
    $.Primitives_timerFrequency = 1000000;
    $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$as(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index, null, null));
  },
  checkInt: function(value) {
    if (typeof value !== "number" || Math.floor(value) !== value)
      throw H.wrapException(P.ArgumentError$(value));
    return value;
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      $function.$reflectionInfo = reflectionInfo;
      functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    } else
      functionType = reflectionInfo;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    $prototype.$requiredArgCount = $function.$requiredArgCount;
    $prototype.$defaultValues = $function.$defaultValues;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t2 = !t1 || arity >= 27;
    if (t2)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(new H.RuntimeError("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, lookedUpFunction, t2, t3, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t3 = !t2 || arity >= 28;
    if (t3)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    var t1;
    functions.fixed$length = Array;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      reflectionInfo.fixed$length = Array;
      t1 = reflectionInfo;
    } else
      t1 = reflectionInfo;
    return H.Closure_fromTearOff(receiver, functions, t1, !!isStatic, jsArguments, $name);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(new P.CyclicInitializationError("Cyclic initialization for static " + H.S(staticName)));
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, t1, argument;
    if (types == null)
      return "";
    buffer = new P.StringBuffer("");
    for (index = startIndex, firstArgument = true, allDynamic = true, t1 = ""; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents = t1 + ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      t1 = buffer._contents += H.S(H.runtimeTypeToString(argument, onTypeVariable));
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = Array;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  Primitives_initTicker_closure: {
    "^": "Closure;performance_0",
    call$0: function() {
      return C.JSNumber_methods.toInt$0(Math.floor(1000 * this.performance_0.now()));
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    get$$call: function() {
      return this;
    },
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    static: {BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = Array;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + this.message;
    }
  }
}],
["benchmark_base", "../../common/dart/BenchmarkBase.dart", , V, {
  "^": "",
  BenchmarkBase_measureFor: function(f, timeMinimum) {
    var watch, iter, elapsed, t1, t2;
    watch = new P.Stopwatch(null, null);
    H.Primitives_initTicker();
    $.Stopwatch__frequency = $.Primitives_timerFrequency;
    watch.start$0();
    for (iter = 0, elapsed = 0; elapsed < timeMinimum;) {
      f.call$0();
      t1 = watch.get$elapsedTicks();
      t2 = $.Stopwatch__frequency;
      if (typeof t2 !== "number")
        return H.iae(t2);
      elapsed = C.JSNumber_methods.$tdiv(t1 * 1000, t2);
      ++iter;
    }
    return 1000 * elapsed / iter;
  },
  BenchmarkBase: {
    "^": "Object;name<",
    warmup$0: function() {
    },
    exercise$0: function() {
      for (var i = 0; i < 10; ++i)
        ;
    },
    measure$0: function() {
      V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure(this), 100);
      return V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure0(this), 2000);
    }
  },
  BenchmarkBase_measure_closure: {
    "^": "Closure;this_0",
    call$0: function() {
      this.this_0.warmup$0();
    }
  },
  BenchmarkBase_measure_closure0: {
    "^": "Closure;this_1",
    call$0: function() {
      this.this_1.exercise$0();
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 1],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 2],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = new P.StringBuffer(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = buffer;
    t1._contents = t1.get$_contents() + rightDelimiter;
    t1 = buffer.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i)
      if (o === t1[i])
        return true;
    return false;
  },
  _HashMap: {
    "^": "Object;_length,_strings,_nums,_rest,_keys",
    get$length: function(_) {
      return this._length;
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var nums;
      if ((key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._length;
        this._keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._length;
          this._keys = null;
        }
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._length;
        this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    static: {_HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  Error_safeToString: function(object) {
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string")
      return JSON.stringify(object);
    return H.Primitives_objectToString(object);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 3],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 4],
  bool: {
    "^": "Object;"
  },
  "+bool": 0,
  $double: {
    "^": "num;"
  },
  "+double": 0,
  Error: {
    "^": "Object;"
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;_hasValue,invalidValue,name<,message",
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var t1, message, prefix, explanation, errorValue;
      t1 = this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = this.get$_errorName() + message;
      if (!this._hasValue)
        return prefix;
      explanation = this.get$_errorExplanation();
      errorValue = P.Error_safeToString(this.invalidValue);
      return prefix + explanation + ": " + H.S(errorValue);
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(false, null, null, message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;start,end,_hasValue,invalidValue,name,message",
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var t1, explanation, t2;
      t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else {
          if (typeof t2 !== "number")
            return t2.$gt();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (t2 > t1)
            explanation = ": Not in range " + t1 + ".." + t2 + ", inclusive";
          else
            explanation = t2 < t1 ? ": Valid value range is empty" : ": Only valid value is " + t1;
        }
      }
      return explanation;
    },
    static: {RangeError$value: function(value, $name, message) {
        return new P.RangeError(null, null, true, value, $name, "Value not in range");
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(this.modifiedObject)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    }
  },
  $int: {
    "^": "num;"
  },
  "+int": 0,
  List: {
    "^": "Object;"
  },
  "+List": 0,
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;"
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Stopwatch: {
    "^": "Object;_start,_stop",
    start$0: function() {
      var t1, t2;
      t1 = this._start == null;
      if (!t1 && true)
        return;
      t2 = $.Primitives_timerTicks;
      if (t1)
        this._start = t2.call$0();
      else {
        t1 = t2.call$0();
        t2 = C.JSNull_methods.$sub(this._stop, this._start);
        if (typeof t1 !== "number")
          return t1.$sub();
        this._start = C.JSNumber_methods.$sub(t1, t2);
        this._stop = null;
      }
    },
    get$elapsedTicks: function() {
      var t1, t2;
      if (this._start == null)
        return 0;
      t1 = $.Primitives_timerTicks.call$0();
      t2 = this._start;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 - t2;
      t1 = t2;
      return t1;
    }
  },
  String: {
    "^": "Object;"
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    writeAll$2: function(objects, separator) {
      var iterator = new J.ArrayIterator(objects, objects.length, 0, null);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do
          this._contents += H.S(iterator._current);
        while (iterator.moveNext$0());
      } else {
        this._contents += H.S(iterator._current);
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          this._contents += H.S(iterator._current);
        }
      }
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
];
parseReflectionData(dart);
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  return receiver;
};
J.getInterceptor$as = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  return receiver;
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$length$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$length(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
C.JSArray_methods = J.JSArray.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
{
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    $dart_deferred_initializers[hunkHash](globalsHolder, $);
    init.deferredInitialized[hunkHash] = true;
  };
}
init.deferredLibraryUris = {};
init.deferredLibraryHashes = {};
$.numBasicBlocks = 0;
$.Primitives_timerFrequency = null;
$.Primitives_timerTicks = null;
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.printToZone = null;
$.Stopwatch__frequency = null;
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});

init.metadata = [{func: "num_", ret: P.num},
{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = Object.create(null);
  init.allClasses = Object.create(null);
  init.getTypeFromName = function(name) {
    return init.allClasses[name];
  };
  init.interceptorsByTag = Object.create(null);
  init.leafTags = Object.create(null);
  init.finishedClasses = Object.create(null);
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    if (!init.lazies)
      init.lazies = Object.create(null);
    init.lazies[fieldName] = getterName;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              $[fieldName] = null;
          }
        } else
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var staticNames = Object.keys(isolateProperties);
      for (var i = 0; i < staticNames.length; i++) {
        var staticName = staticNames[i];
        this[staticName] = isolateProperties[staticName];
      }
      var lazies = init.lazies;
      var lazyInitializers = lazies ? Object.keys(lazies) : [];
      for (var i = 0; i < lazyInitializers.length; i++)
        this[lazies[lazyInitializers[i]]] = null;
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
      for (var i = 0; i < lazyInitializers.length; i++) {
        var lazyInitName = lazies[lazyInitializers[i]];
        this[lazyInitName] = isolateProperties[lazyInitName];
      }
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    return Isolate;
  };
}
;// BEGIN invoke [main].
(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].removeEventListener("load", onLoad, false);
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i)
    scripts[i].addEventListener("load", onLoad, false);
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function")
    dartMainRunner(A.main, []);
  else
    A.main([]);
});
;
// END invoke [main].
})()

//# sourceMappingURL=Havlak.dart.js.map
