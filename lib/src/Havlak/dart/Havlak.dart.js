// Generated by dart2js, the Dart to JavaScript compiler version: 1.4.3.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart(){ this.x = 0 }var A = new dart;
delete A.x;
var B = new dart;
delete B.x;
var C = new dart;
delete C.x;
var D = new dart;
delete D.x;
var E = new dart;
delete E.x;
var F = new dart;
delete F.x;
var G = new dart;
delete G.x;
var H = new dart;
delete H.x;
var J = new dart;
delete J.x;
var K = new dart;
delete K.x;
var L = new dart;
delete L.x;
var M = new dart;
delete M.x;
var N = new dart;
delete N.x;
var O = new dart;
delete O.x;
var P = new dart;
delete P.x;
var Q = new dart;
delete Q.x;
var R = new dart;
delete R.x;
var S = new dart;
delete S.x;
var T = new dart;
delete T.x;
var U = new dart;
delete U.x;
var V = new dart;
delete V.x;
var W = new dart;
delete W.x;
var X = new dart;
delete X.x;
var Y = new dart;
delete Y.x;
var Z = new dart;
delete Z.x;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = {};

(function(reflectionData) {
  "use strict";
  function map(x) {
    x = {x: x};
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["", "Havlak.dart", , A, {
  "^": "",
  main: function() {
    var t1, score, line;
    t1 = A.Havlak$();
    score = t1.measure$0();
    line = t1.name + "(RunTime): " + H.S(score) + " us.";
    H.printString(line);
  },
  buildDiamond: function(cfg, start) {
    var t1, t2, t3;
    t1 = start + 1;
    A.BasicBlockEdge$(cfg, start, t1);
    t2 = start + 2;
    A.BasicBlockEdge$(cfg, start, t2);
    t3 = start + 3;
    A.BasicBlockEdge$(cfg, t1, t3);
    A.BasicBlockEdge$(cfg, t2, t3);
    return t3;
  },
  buildStraight: function(cfg, start, n) {
    var t1, i, t2, t3, t4;
    for (t1 = cfg.edgeList, i = 0; i < n; ++i) {
      t2 = start + i;
      t3 = new A.BasicBlockEdge(null, null);
      t4 = cfg.createNode$1(t2);
      t3.from = t4;
      t2 = cfg.createNode$1(t2 + 1);
      t3.to = t2;
      t4.addOutEdge$1(t2);
      t2.addInEdge$1(t4);
      t1.push(t3);
    }
    return start + n;
  },
  buildBaseLoop: function(cfg, from) {
    var header, diamond1, d11, diamond2, footer, t1, t2, t3, t4;
    header = A.buildStraight(cfg, from, 1);
    diamond1 = A.buildDiamond(cfg, header);
    d11 = A.buildStraight(cfg, diamond1, 1);
    diamond2 = A.buildDiamond(cfg, d11);
    footer = A.buildStraight(cfg, diamond2, 1);
    t1 = new A.BasicBlockEdge(null, null);
    t2 = cfg.createNode$1(diamond2);
    t1.from = t2;
    t3 = cfg.createNode$1(d11);
    t1.to = t3;
    t2.addOutEdge$1(t3);
    t3.addInEdge$1(t2);
    t2 = cfg.edgeList;
    t2.push(t1);
    t1 = new A.BasicBlockEdge(null, null);
    t3 = cfg.createNode$1(diamond1);
    t1.from = t3;
    t4 = cfg.createNode$1(header);
    t1.to = t4;
    t3.addOutEdge$1(t4);
    t4.addInEdge$1(t3);
    t2.push(t1);
    t1 = new A.BasicBlockEdge(null, null);
    t3 = cfg.createNode$1(footer);
    t1.from = t3;
    t4 = cfg.createNode$1(from);
    t1.to = t4;
    t3.addOutEdge$1(t4);
    t4.addInEdge$1(t3);
    t2.push(t1);
    return A.buildStraight(cfg, footer, 1);
  },
  BasicBlock: {
    "^": "Object;name<,inEdges,outEdges<",
    toString$0: function(_) {
      return "BB" + this.name;
    },
    getNumPred$0: function() {
      return this.inEdges.length;
    },
    addInEdge$1: function(bb) {
      return this.inEdges.push(bb);
    },
    addOutEdge$1: function(bb) {
      return this.outEdges.push(bb);
    }
  },
  BasicBlockEdge: {
    "^": "Object;from,to",
    BasicBlockEdge$3: function(cfg, fromName, toName) {
      var t1;
      this.from = cfg.createNode$1(fromName);
      t1 = cfg.createNode$1(toName);
      this.to = t1;
      this.from.addOutEdge$1(t1);
      this.to.addInEdge$1(this.from);
      cfg.edgeList.push(this);
    },
    static: {BasicBlockEdge$: function(cfg, fromName, toName) {
        var t1 = new A.BasicBlockEdge(null, null);
        t1.BasicBlockEdge$3(cfg, fromName, toName);
        return t1;
      }}
  },
  CFG: {
    "^": "Object;basicBlockMap,edgeList,startNode",
    createNode$1: function($name) {
      var t1, node;
      t1 = this.basicBlockMap;
      node = t1.$index(0, $name);
      if (node == null) {
        node = new A.BasicBlock($name, [], []);
        $.numBasicBlocks = $.numBasicBlocks + 1;
        t1.$indexSet(0, $name, node);
      }
      if (t1._length === 1)
        this.startNode = node;
      return node;
    }
  },
  SimpleLoop: {
    "^": "Object;basicBlocks,children,counter,parent,header,isRoot,isReducible,nestingLevel,depthLevel",
    setNestingLevel$1: function(level) {
      this.nestingLevel = level;
      if (level === 0)
        this.isRoot = true;
    },
    checksum$0: function() {
      var t1, result, t2;
      t1 = {};
      result = this.counter;
      t1.result_0 = result;
      t2 = this.isRoot ? 1 : 0;
      result = ((result & 268435455) << 1 >>> 0) + t2;
      t1.result_0 = result;
      t2 = this.isReducible ? 1 : 0;
      result = ((result & 268435455) << 1 >>> 0) + t2;
      t1.result_0 = result;
      result = ((result & 268435455) << 1 >>> 0) + this.nestingLevel;
      t1.result_0 = result;
      result = ((result & 268435455) << 1 >>> 0) + this.depthLevel;
      t1.result_0 = result;
      t2 = this.header;
      if (t2 != null) {
        t2 = t2.get$name();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.result_0 = ((result & 268435455) << 1 >>> 0) + t2;
      }
      H.IterableMixinWorkaround_forEach(this.basicBlocks, new A.SimpleLoop_checksum_closure(t1));
      H.IterableMixinWorkaround_forEach(this.children, new A.SimpleLoop_checksum_closure0(t1));
      return t1.result_0;
    }
  },
  SimpleLoop_checksum_closure: {
    "^": "Closure;box_0",
    call$1: function(e) {
      var t1, t2, t3, result;
      t1 = this.box_0;
      t2 = t1.result_0;
      t3 = e.get$name();
      if (typeof t3 !== "number")
        return H.iae(t3);
      result = ((t2 & 268435455) << 1 >>> 0) + t3;
      t1.result_0 = result;
      return result;
    }
  },
  SimpleLoop_checksum_closure0: {
    "^": "Closure;box_0",
    call$1: function(e) {
      var t1, result;
      t1 = this.box_0;
      result = ((t1.result_0 & 268435455) << 1 >>> 0) + e.checksum$0();
      t1.result_0 = result;
      return result;
    }
  },
  LSG: {
    "^": "Object;loopCounter,loops,root",
    checksum$0: function() {
      var t1, t2;
      t1 = {};
      t2 = this.loops;
      t1.result_0 = t2.length;
      H.IterableMixinWorkaround_forEach(t2, new A.LSG_checksum_closure(t1));
      return ((t1.result_0 & 268435455) << 1 >>> 0) + this.root.checksum$0();
    }
  },
  LSG_checksum_closure: {
    "^": "Closure;box_0",
    call$1: function(e) {
      var t1, result;
      t1 = this.box_0;
      result = ((t1.result_0 & 268435455) << 1 >>> 0) + e.checksum$0();
      t1.result_0 = result;
      return result;
    }
  },
  UnionFindNode: {
    "^": "Object;dfsNumber<,parent,bb,loop",
    findSet$0: function() {
      var nodeList, node, t1, t2, iter;
      nodeList = [];
      for (node = this; t1 = node.parent, node !== t1;) {
        t2 = t1.parent;
        if (t1 == null ? t2 != null : t1 !== t2)
          nodeList.push(node);
        node = node.parent;
      }
      for (iter = 0; iter < nodeList.length; ++iter)
        nodeList[iter].parent = node.parent;
      return node;
    }
  },
  HavlakLoopFinder: {
    "^": "Object;cfg,lsg",
    DFS$5: function(currentNode, nodes, number, last, current) {
      var t1, t2, lastid, target, t3;
      if (current >= nodes.length)
        return H.ioore(nodes, current);
      t1 = nodes[current];
      t1.parent = t1;
      t1.bb = currentNode;
      t1.dfsNumber = current;
      t1 = currentNode.get$name();
      t2 = number.length;
      if (t1 >>> 0 !== t1 || t1 >= t2)
        return H.ioore(number, t1);
      number[t1] = current;
      for (lastid = current, target = 0; target < currentNode.get$outEdges().length; ++target) {
        t1 = currentNode.outEdges;
        if (target >= t1.length)
          return H.ioore(t1, target);
        t3 = t1[target].get$name();
        if (t3 >>> 0 !== t3 || t3 >= t2)
          return H.ioore(number, t3);
        if (number[t3] === -1) {
          if (target >= t1.length)
            return H.ioore(t1, target);
          lastid = this.DFS$5(t1[target], nodes, number, last, lastid + 1);
        }
      }
      t1 = currentNode.name;
      if (t1 >= t2)
        return H.ioore(number, t1);
      t1 = number[t1];
      if (t1 >>> 0 !== t1 || t1 >= last.length)
        return H.ioore(last, t1);
      last[t1] = lastid;
      return lastid;
    },
    findLoops$0: function() {
      var t1, t2, size, nonBackPreds, backPreds, number, header, types, last, nodes, i, w, nodeW, nv, v, nodePool, vi, t3, workList, n, x, iter, ydash, t4, loop, np, node, t5;
      t1 = this.cfg;
      t2 = t1.startNode;
      if (t2 == null)
        return 0;
      size = t1.basicBlockMap._length;
      nonBackPreds = Array(size);
      backPreds = Array(size);
      number = Array(size);
      header = Array(size);
      types = Array(size);
      last = Array(size);
      nodes = Array(size);
      for (i = 0; i < size; ++i) {
        nonBackPreds[i] = [];
        backPreds[i] = [];
        number[i] = -1;
        header[i] = 0;
        types[i] = 1;
        last[i] = 0;
        nodes[i] = new A.UnionFindNode(0, null, null, null);
      }
      this.DFS$5(t2, nodes, number, last, 0);
      for (w = 0; w < size; ++w) {
        nodeW = nodes[w].bb;
        if (nodeW == null)
          types[w] = 5;
        else if (nodeW.getNumPred$0() > 0)
          for (t1 = nodeW.inEdges, nv = 0; nv < t1.length; ++nv) {
            t2 = t1[nv].get$name();
            if (t2 >>> 0 !== t2 || t2 >= size)
              return H.ioore(number, t2);
            v = number[t2];
            if (v !== -1) {
              if (typeof v !== "number")
                return H.iae(v);
              if (w <= v) {
                if (w >= size)
                  return H.ioore(last, w);
                t2 = last[w];
                if (typeof t2 !== "number")
                  return H.iae(t2);
                t2 = v <= t2;
              } else
                t2 = false;
              if (t2)
                backPreds[w].push(v);
              else
                nonBackPreds[w].push(v);
            }
          }
      }
      for (w = size - 1, t1 = this.lsg, t2 = t1.loops; w >= 0; --w) {
        nodePool = [];
        nodeW = nodes[w].bb;
        if (nodeW == null)
          continue;
        for (vi = 0; t3 = backPreds[w], vi < t3.length; ++vi) {
          v = t3[vi];
          if (v !== w) {
            if (v >>> 0 !== v || v >= size)
              return H.ioore(nodes, v);
            nodePool.push(nodes[v].findSet$0());
          } else
            types[w] = 3;
        }
        workList = [];
        for (n = 0; t3 = nodePool.length, n < t3; ++n)
          workList.push(nodePool[n]);
        if (t3 !== 0)
          types[w] = 2;
        for (; workList.length > 0;) {
          x = workList.splice(0, 1)[0];
          t3 = x.get$dfsNumber();
          if (t3 >= size)
            return H.ioore(nonBackPreds, t3);
          if (nonBackPreds[t3].length > 32768)
            return 0;
          iter = 0;
          while (true) {
            t3 = x.dfsNumber;
            if (t3 >= size)
              return H.ioore(nonBackPreds, t3);
            t3 = nonBackPreds[t3];
            if (!(iter < t3.length))
              break;
            t3 = t3[iter];
            if (t3 >>> 0 !== t3 || t3 >= size)
              return H.ioore(nodes, t3);
            ydash = nodes[t3].findSet$0();
            t3 = ydash.dfsNumber;
            if (w <= t3) {
              if (w >= size)
                return H.ioore(last, w);
              t4 = last[w];
              if (typeof t4 !== "number")
                return H.iae(t4);
              t4 = t3 <= t4;
            } else
              t4 = false;
            if (!t4) {
              types[w] = 4;
              nonBackPreds[w].push(t3);
            } else if (t3 !== w)
              if (H.Lists_indexOf(nodePool, ydash, 0, nodePool.length) === -1) {
                workList.push(ydash);
                nodePool.push(ydash);
              }
            ++iter;
          }
        }
        if (nodePool.length > 0 || types[w] === 3) {
          t3 = [];
          t4 = [];
          loop = new A.SimpleLoop(t3, t4, t1.loopCounter++, null, null, false, true, 0, 0);
          t3.push(nodeW);
          loop.header = nodeW;
          if (types[w] === 4)
            loop.isReducible = true;
          else
            loop.isReducible = false;
          nodes[w].loop = loop;
          for (np = 0; np < nodePool.length; ++np) {
            node = nodePool[np];
            t5 = node.dfsNumber;
            if (t5 >= size)
              return H.ioore(header, t5);
            header[t5] = w;
            node.parent = nodes[w];
            t5 = node.loop;
            if (t5 != null) {
              t5.parent = loop;
              t4.push(t5);
            } else
              t3.push(node.bb);
          }
          t2.push(loop);
        }
      }
      return t2.length;
    },
    static: {"^": "HavlakLoopFinder_BB_TOP,HavlakLoopFinder_BB_NONHEADER,HavlakLoopFinder_BB_REDUCIBLE,HavlakLoopFinder_BB_SELF,HavlakLoopFinder_BB_IRREDUCIBLE,HavlakLoopFinder_BB_DEAD,HavlakLoopFinder_BB_LAST,HavlakLoopFinder_UNVISITED,HavlakLoopFinder_MAXNONBACKPREDS"}
  },
  Havlak: {
    "^": "BenchmarkBase;cfg,name",
    exercise$0: function() {
      var t1, t2, numLoops;
      t1 = [];
      t2 = new A.SimpleLoop([], [], 0, null, null, false, true, 0, 0);
      t2.setNestingLevel$1(0);
      t1.push(t2);
      numLoops = new A.HavlakLoopFinder(this.cfg, new A.LSG(1, t1, t2)).findLoops$0();
      if (numLoops !== 1522)
        throw H.wrapException("Wrong result - expected <1522>, but was <" + numLoops + ">");
    },
    warmup$0: function() {
      var t1, dummyloop, t2, t3, lsg, checksum;
      for (t1 = this.cfg, dummyloop = 0; dummyloop < 20; ++dummyloop) {
        t2 = [];
        t3 = new A.SimpleLoop([], [], 0, null, null, false, true, 0, 0);
        lsg = new A.LSG(1, t2, t3);
        t3.nestingLevel = 0;
        t3.isRoot = true;
        t2.push(t3);
        new A.HavlakLoopFinder(t1, lsg).findLoops$0();
        checksum = lsg.checksum$0();
        if (checksum !== 435630002)
          throw H.wrapException("Wrong checksum - expected <435630002>, but was <" + H.S(checksum) + ">");
      }
    },
    Havlak$0: function() {
      var t1, t2, n, parlooptrees, n0, t3, t4, t5, i, j, bottom;
      t1 = this.cfg;
      t1.createNode$1(0);
      A.buildBaseLoop(t1, 0);
      t1.createNode$1(1);
      A.BasicBlockEdge$(t1, 0, 2);
      for (t2 = t1.edgeList, n = 2, parlooptrees = 0; parlooptrees < 10; ++parlooptrees) {
        n0 = n + 1;
        t1.createNode$1(n0);
        t3 = new A.BasicBlockEdge(null, null);
        t4 = t1.createNode$1(n);
        t3.from = t4;
        t5 = t1.createNode$1(n0);
        t3.to = t5;
        t4.addOutEdge$1(t5);
        t5.addInEdge$1(t4);
        t2.push(t3);
        for (n = n0, i = 0; i < 2; ++i, n = bottom) {
          n0 = A.buildStraight(t1, n, 1);
          for (j = 0; j < 25; ++j)
            n0 = A.buildBaseLoop(t1, n0);
          bottom = A.buildStraight(t1, n0, 1);
          t3 = new A.BasicBlockEdge(null, null);
          t4 = t1.createNode$1(n0);
          t3.from = t4;
          t5 = t1.createNode$1(n);
          t3.to = t5;
          t4.addOutEdge$1(t5);
          t5.addInEdge$1(t4);
          t2.push(t3);
        }
      }
    },
    static: {Havlak$: function() {
        var t1 = new A.Havlak(new A.CFG(P.HashMap_HashMap(null, null, null, null, null), [], null), "Havlak");
        t1.Havlak$0();
        return t1;
      }}
  }
},
1],
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    }
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    }
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    }
  },
  JSArray: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return H.IterableMixinWorkaround_toStringIterable(receiver, "[", "]");
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isJSArray: true
  },
  JSNumber: {
    "^": "Interceptor;",
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    $isnum: true
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      return receiver.charCodeAt(index);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isString: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_numMicroseconds: function() {
    if (typeof window != "undefined" && window !== null) {
      var performance = window.performance;
      if (performance != null && typeof performance.webkitNow == "function")
        return C.JSNumber_methods.toInt$0(Math.floor(1000 * performance.webkitNow()));
    }
    return 1000 * Date.now();
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$as(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index));
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = init;
    reflectionInfo.fixed$length = init;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = init;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = init;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  }
}],
["benchmark_base", "../../common/dart/BenchmarkBase.dart", , V, {
  "^": "",
  BenchmarkBase_measureFor: function(f, timeMinimum) {
    var watch, iter, elapsed;
    watch = new P.Stopwatch(1000000, null, null);
    watch.start$0();
    for (iter = 0, elapsed = 0; elapsed < timeMinimum;) {
      f.call$0();
      elapsed = C.JSNumber_methods._tdivFast$1(watch.get$elapsedTicks() * 1000, 1000000);
      ++iter;
    }
    return 1000 * elapsed / iter;
  },
  BenchmarkBase: {
    "^": "Object;name<",
    warmup$0: function() {
    },
    exercise$0: function() {
      for (var i = 0; i < 10; ++i)
        ;
    },
    measure$0: function() {
      V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure(this), 100);
      return V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure0(this), 2000);
    }
  },
  BenchmarkBase_measure_closure: {
    "^": "Closure;this_0",
    call$0: function() {
      this.this_0.warmup$0();
    }
  },
  BenchmarkBase_measure_closure0: {
    "^": "Closure;this_1",
    call$0: function() {
      this.this_1.exercise$0();
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableMixinWorkaround_forEach: function(iterable, f) {
    var t1;
    for (t1 = new H.ListIterator(iterable, iterable.length, 0, null); t1.moveNext$0();)
      f.call$1(t1._current);
  },
  IterableMixinWorkaround_toStringIterable: function(iterable, leftDelimiter, rightDelimiter) {
    var result, i, t1;
    for (i = 0; t1 = $.get$IterableMixinWorkaround__toStringList(), i < t1.length; ++i)
      if (t1[i] === iterable)
        return H.S(leftDelimiter) + "..." + H.S(rightDelimiter);
    result = P.StringBuffer$("");
    try {
      $.get$IterableMixinWorkaround__toStringList().push(iterable);
      result.write$1(leftDelimiter);
      result.writeAll$2(iterable, ", ");
      result.write$1(rightDelimiter);
    } finally {
      t1 = $.get$IterableMixinWorkaround__toStringList();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    return result.get$_contents();
  },
  Lists_indexOf: function(a, element, startIndex, endIndex) {
    var i;
    if (startIndex >= a.length)
      return -1;
    for (i = startIndex; i < endIndex; ++i) {
      if (i >= a.length)
        return H.ioore(a, i);
      if (J.$eq(a[i], element))
        return i;
    }
    return -1;
  },
  ListIterator: {
    "^": "Object;_iterable,__internal$_length,_index,_current",
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this._iterable;
      $length = t1.length;
      if (this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this._index;
      if (t2 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t1[t2];
      this._index = t2 + 1;
      return true;
    }
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 0],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 1],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  _HashMap: {
    "^": "Object;_length,_strings,_nums,_rest,_keys",
    get$length: function(_) {
      return this._length;
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var nums;
      if ((key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._length;
        this._keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._length;
          this._keys = null;
        }
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._length;
        this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    static: {_HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  Error_safeToString: function(object) {
    return H.Primitives_objectToString(object);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 2],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 3],
  bool: {
    "^": "Object;",
    toString$0: function(_) {
      return this ? "true" : "false";
    }
  },
  "+bool": 0,
  $double: {
    "^": "num;"
  },
  "+double": 0,
  Error: {
    "^": "Object;"
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Illegal argument(s): " + H.S(t1);
      return "Illegal argument(s)";
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;message",
    toString$0: function(_) {
      return "RangeError: " + H.S(this.message);
    },
    static: {RangeError$value: function(value) {
        return new P.RangeError("value " + H.S(value));
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + P.Error_safeToString(this.modifiedObject) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  List: {
    "^": "Object;"
  },
  "+List": 0,
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Stopwatch: {
    "^": "Object;frequency,_start,_stop",
    start$0: function() {
      var t1 = this._start == null;
      if (!t1 && true)
        return;
      if (t1)
        this._start = H.Primitives_numMicroseconds();
      else {
        this._start = C.JSNumber_methods.$sub(H.Primitives_numMicroseconds(), C.JSNull_methods.$sub(this._stop, this._start));
        this._stop = null;
      }
    },
    get$elapsedTicks: function() {
      var t1, t2;
      if (this._start == null)
        return 0;
      t1 = H.Primitives_numMicroseconds();
      t2 = this._start;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = t1 - t2;
      t1 = t2;
      return t1;
    }
  },
  String: {
    "^": "Object;",
    $isString: true
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = new H.ListIterator(objects, objects.length, 0, null);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0)
        do {
          str = iterator._current;
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      else {
        this.write$1(iterator._current);
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator._current;
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    toString$0: function(_) {
      return this._contents;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log == "function") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  return receiver;
};
J.getInterceptor$as = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  return receiver;
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$length$as = function(receiver) {
  return J.getInterceptor$as(receiver).get$length(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
$.libraries_to_load = {};
$.numBasicBlocks = 0;
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.printToZone = null;
Isolate.$lazy($, "_toStringList", "IterableMixinWorkaround__toStringList", "get$IterableMixinWorkaround__toStringList", function() {
  return [];
});

init.functionAliases = {};
;
init.metadata = [{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {};
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
// BEGIN invoke [main].
;(function (callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }

  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;

  if (typeof dartMainRunner === "function") {
    dartMainRunner(A.main, []);
  } else {
    A.main([]);
  }
});
// END invoke [main].
function init() {
  Isolate.$isolateProperties = {};
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties)
        if (hasOwnProperty.call(properties, member))
          object[member] = properties[member];
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = {};
    if (!init.allClasses)
      init.allClasses = {};
    var allClasses = init.allClasses;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      var constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      if (hasOwnProperty.call(collectedClasses, cls)) {
        var desc = collectedClasses[cls];
        if (desc instanceof Array)
          desc = desc[1];
        var classData = desc["^"], supr, name = cls, fields = classData;
        if (typeof classData == "string") {
          var split = classData.split("/");
          if (split.length == 2) {
            name = split[0];
            fields = split[1];
          }
        }
        var s = fields.split(";");
        fields = s[1] == "" ? [] : s[1].split(",");
        supr = s[0];
        split = supr.split(":");
        if (split.length == 2) {
          supr = split[0];
          var functionSignature = split[1];
          if (functionSignature)
            desc.$signature = function(s) {
              return function() {
                return init.metadata[s];
              };
            }(functionSignature);
        }
        if (typeof dart_precompiled != "function") {
          combinedConstructorFunction += defineClass(name, cls, fields);
          constructorsList.push(cls);
        }
        if (supr)
          pendingClasses[cls] = supr;
      }
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = {};
    init.interceptorsByTag = Object.create(null);
    init.leafTags = {};
    function finishClass(cls) {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      if (hasOwnProperty.call(finishedClasses, cls))
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              if ($[fieldName] === sentinelInProgress)
                $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    return Isolate;
  };
}
})()

//# sourceMappingURL=Havlak.dart.js.map
//@ sourceMappingURL=Havlak.dart.js.map
