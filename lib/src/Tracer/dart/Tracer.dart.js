// Generated by dart2js, the Dart to JavaScript compiler version: 1.9.1.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferered library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
(function($) {
function map(x) {
  x = Object.create(null);
  x.x = 0;
  delete x.x;
  return x;
}
var A = map();
var B = map();
var C = map();
var D = map();
var E = map();
var F = map();
var G = map();
var H = map();
var J = map();
var K = map();
var L = map();
var M = map();
var N = map();
var O = map();
var P = map();
var Q = map();
var R = map();
var S = map();
var T = map();
var U = map();
var V = map();
var W = map();
var X = map();
var Y = map();
var Z = map();
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
$.functionThatReturnsNull = function() {
};
;
function parseReflectionData(reflectionData) {
  "use strict";
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  function defineClass(name, fields) {
    var accessors = [];
    var str = "function " + name + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, name);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += name + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + name + ";\n";
    str += "if($desc instanceof Array) $desc = \$desc[1];\n";
    str += name + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string")
      str += name + ".name=\"" + name + "\";\n";
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    return function(constructor, superConstructor) {
      if (superConstructor == null) {
        var prototype = constructor.prototype;
        prototype.constructor = constructor;
        prototype.$isObject = constructor;
        return prototype;
      }
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      var members = Object.keys(properties);
      for (var i = 0; i < members.length; i++) {
        var member = members[i];
        object[member] = properties[member];
      }
      object["$is" + constructor.name] = constructor;
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  function finishClasses(processedClasses) {
    var allClasses = init.allClasses;
    processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
    var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
    processedClasses.combinedConstructorFunction = null;
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = processedClasses.collected[cls];
      var globalObject = $;
      if (desc instanceof Array) {
        globalObject = desc[0] || $;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = init.finishedClasses;
    function finishClass(cls) {
      if (finishedClasses[cls])
        return;
      finishedClasses[cls] = true;
      var superclass = processedClasses.pending[cls];
      if (superclass && superclass.indexOf("+") > 0) {
        var s = superclass.split("+");
        superclass = s[0];
        var mixinClass = s[1];
        finishClass(mixinClass);
        var mixin = allClasses[mixinClass];
        var mixinPrototype = mixin.prototype;
        var clsPrototype = allClasses[cls].prototype;
        var properties = Object.keys(mixinPrototype);
        for (var i = 0; i < properties.length; i++) {
          var d = properties[i];
          if (!hasOwnProperty.call(clsPrototype, d))
            clsPrototype[d] = mixinPrototype[d];
        }
      }
      if (!superclass || typeof superclass != "string") {
        inheritFrom(allClasses[cls], null);
        return;
      }
      finishClass(superclass);
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var constructor = allClasses[cls];
      var prototype = inheritFrom(constructor, superConstructor);
      if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
      }
    }
    var properties = Object.keys(processedClasses.pending);
    for (var i = 0; i < properties.length; i++)
      finishClass(properties[i]);
  }
  function processClassData(cls, descriptor, processedClasses) {
    var newDesc = {};
    var previousProperty;
    var properties = Object.keys(descriptor);
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      var firstChar = property.substring(0, 1);
      if (property === "static")
        processStatics(init.statics[cls] = descriptor[property], processedClasses);
      else if (firstChar === "+") {
        mangledNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
      } else if (firstChar === "*") {
        newDesc[previousProperty].$defaultValues = descriptor[property];
        var optionalMethods = newDesc.$methodsWithOptionalArguments;
        if (!optionalMethods)
          newDesc.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else {
        var elem = descriptor[property];
        if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
          addStubs(newDesc, elem, property, false, descriptor, []);
        else
          newDesc[previousProperty = property] = elem;
      }
    }
    var classData = newDesc["^"], split, supr, fields = classData;
    var s = fields.split(";");
    fields = s[1] == "" ? [] : s[1].split(",");
    supr = s[0];
    split = supr.split(":");
    if (split.length == 2) {
      supr = split[0];
      var functionSignature = split[1];
      if (functionSignature)
        newDesc.$signature = function(s) {
          return function() {
            return init.metadata[s];
          };
        }(functionSignature);
    }
    if (supr)
      processedClasses.pending[cls] = supr;
    processedClasses.combinedConstructorFunction += defineClass(cls, fields);
    processedClasses.constructorsList.push(cls);
    processedClasses.collected[cls] = [globalObject, newDesc];
    classes.push(cls);
  }
  function processStatics(descriptor, processedClasses) {
    var properties = Object.keys(descriptor);
    for (var i = 0; i < properties.length; i++) {
      var property = properties[i];
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods)
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array)
        addStubs(globalObject, element, property, true, descriptor, functions);
      else {
        previousProperty = property;
        processClassData(property, element, processedClasses);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var index = 0, alias = array[index], f;
    if (typeof alias == "string")
      f = array[++index];
    else {
      f = alias;
      alias = name;
    }
    var funcs = [originalDescriptor[name] = descriptor[name] = descriptor[alias] = f];
    f.$stubName = name;
    functions.push(name);
    for (; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++)
      funcs[i].$callName = array[index + 1];
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
    }
  }
  function tearOffGetter(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  var processedClasses = Object.create(null);
  processedClasses.collected = Object.create(null);
  processedClasses.pending = Object.create(null);
  processedClasses.constructorsList = [];
  processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor, processedClasses);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
  finishClasses(processedClasses);
}
var dart = [
["", "Tracer.dart", , D, {
  "^": "",
  main: function() {
    var line = "Tracer(RunTime): " + H.S(new D.TracerBenchmark("Tracer").measure$0()) + " us.";
    H.printString(line);
  },
  TracerBenchmark: {
    "^": "BenchmarkBase;name",
    warmup$0: function() {
      D.renderScene(null);
    },
    exercise$0: function() {
      D.renderScene(null);
    }
  }
},
1],
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    }
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isbool: 1
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;"
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    get$iterator: function(receiver) {
      return new J.ArrayIterator(receiver, receiver.length, 0, null);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isList: 1,
    $asList: null
  },
  ArrayIterator: {
    "^": "Object;_iterable,_length,_index,_current",
    get$current: function() {
      return this._current;
    },
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this._iterable;
      $length = t1.length;
      if (this._length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this._index;
      if (t2 >= $length) {
        this._current = null;
        return false;
      }
      this._current = t1[t2];
      this._index = t2 + 1;
      return true;
    }
  },
  JSNumber: {
    "^": "Interceptor;",
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$("" + receiver));
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    $add: function(receiver, other) {
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    $isnum: 1
  },
  JSInt: {
    "^": "JSNumber;",
    $is$double: 1,
    $isnum: 1,
    $is$int: 1
  },
  JSDouble: {
    "^": "JSNumber;",
    $is$double: 1,
    $isnum: 1
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null, null));
      return receiver.charCodeAt(index);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, null, null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $isString: 1
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_dateNow: [function() {
    return Date.now();
  }, "call$0", "Primitives_dateNow$closure", 0, 0, 0],
  Primitives_initTicker: function() {
    var $window, performance;
    if ($.Primitives_timerFrequency != null)
      return;
    $.Primitives_timerFrequency = 1000;
    $.Primitives_timerTicks = H.Primitives_dateNow$closure();
    if (typeof window == "undefined")
      return;
    $window = window;
    if ($window == null)
      return;
    performance = $window.performance;
    if (performance == null)
      return;
    if (typeof performance.now != "function")
      return;
    $.Primitives_timerFrequency = 1000000;
    $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index, null, null));
  },
  checkNum: function(value) {
    return value;
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  invokeClosure: function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return new H.invokeClosure_closure(closure).call$0();
    else if (t1.$eq(numberOfArguments, 1))
      return new H.invokeClosure_closure0(closure, arg1).call$0();
    else if (t1.$eq(numberOfArguments, 2))
      return new H.invokeClosure_closure1(closure, arg1, arg2).call$0();
    else if (t1.$eq(numberOfArguments, 3))
      return new H.invokeClosure_closure2(closure, arg1, arg2, arg3).call$0();
    else if (t1.$eq(numberOfArguments, 4))
      return new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4).call$0();
    else
      throw H.wrapException(new P._ExceptionImplementation("Unsupported number of arguments for wrapped closure"));
  },
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, $, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      $function.$reflectionInfo = reflectionInfo;
      functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    } else
      functionType = reflectionInfo;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else {
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t1, 1);
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    $prototype.$requiredArgCount = $function.$requiredArgCount;
    $prototype.$defaultValues = $function.$defaultValues;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t2 = !t1 || arity >= 27;
    if (t2)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t1, 1);
    return new Function(t2 + H.S(t1) + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(new H.RuntimeError("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, lookedUpFunction, t2, t3, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    t3 = !t2 || arity >= 28;
    if (t3)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ns(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    $.Closure_functionCounter = J.$add$ns(t2, 1);
    return new Function(t1 + H.S(t2) + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    var t1;
    functions.fixed$length = Array;
    if (!!J.getInterceptor(reflectionInfo).$isList) {
      reflectionInfo.fixed$length = Array;
      t1 = reflectionInfo;
    } else
      t1 = reflectionInfo;
    return H.Closure_fromTearOff(receiver, functions, t1, !!isStatic, jsArguments, $name);
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(new P.CyclicInitializationError("Cyclic initialization for static " + H.S(staticName)));
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, t1, argument;
    if (types == null)
      return "";
    buffer = new P.StringBuffer("");
    for (index = startIndex, firstArgument = true, allDynamic = true, t1 = ""; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents = t1 + ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      t1 = buffer._contents += H.S(H.runtimeTypeToString(argument, onTypeVariable));
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    tag = $.getTagFunction.call$1(obj);
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = $.alternateTagFunction.call$2(obj, tag);
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto = Object.getPrototypeOf(obj);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, fun, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      fun = function() {
      };
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null) {
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            fun.prototype = proto;
          }
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_gkc();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc0, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_8ZY), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
    static: {ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = Array;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  Primitives_initTicker_closure: {
    "^": "Closure;performance_0",
    call$0: function() {
      return C.JSNumber_methods.toInt$0(Math.floor(1000 * this.performance_0.now()));
    }
  },
  invokeClosure_closure: {
    "^": "Closure;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    }
  },
  invokeClosure_closure0: {
    "^": "Closure;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    }
  },
  invokeClosure_closure1: {
    "^": "Closure;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    }
  },
  invokeClosure_closure2: {
    "^": "Closure;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    }
  },
  invokeClosure_closure3: {
    "^": "Closure;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    }
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    get$$call: function() {
      return this;
    },
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    static: {BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = Array;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + this.message;
    }
  },
  initHooks_closure: {
    "^": "Closure;getTag_0",
    call$1: function(o) {
      return this.getTag_0(o);
    }
  },
  initHooks_closure0: {
    "^": "Closure;getUnknownTag_1",
    call$2: function(o, tag) {
      return this.getUnknownTag_1(o, tag);
    }
  },
  initHooks_closure1: {
    "^": "Closure;prototypeForTag_2",
    call$1: function(tag) {
      return this.prototypeForTag_2(tag);
    }
  }
}],
["benchmark_base", "../../common/dart/BenchmarkBase.dart", , V, {
  "^": "",
  BenchmarkBase_measureFor: function(f, timeMinimum) {
    var watch, iter, elapsed, t1, t2;
    watch = new P.Stopwatch(null, null);
    H.Primitives_initTicker();
    $.Stopwatch__frequency = $.Primitives_timerFrequency;
    watch.start$0();
    for (iter = 0, elapsed = 0; elapsed < timeMinimum;) {
      f.call$0();
      t1 = J.$mul$ns(watch.get$elapsedTicks(), 1000);
      t2 = $.Stopwatch__frequency;
      if (typeof t1 !== "number")
        return t1.$tdiv();
      if (typeof t2 !== "number")
        return H.iae(t2);
      elapsed = C.JSNumber_methods.$tdiv(t1, t2);
      ++iter;
    }
    return 1000 * elapsed / iter;
  },
  BenchmarkBase: {
    "^": "Object;",
    warmup$0: function() {
    },
    exercise$0: function() {
      for (var i = 0; i < 10; ++i)
        ;
    },
    measure$0: function() {
      V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure(this), 100);
      return V.BenchmarkBase_measureFor(new V.BenchmarkBase_measure_closure0(this), 2000);
    }
  },
  BenchmarkBase_measure_closure: {
    "^": "Closure;this_0",
    call$0: function() {
      this.this_0.warmup$0();
    }
  },
  BenchmarkBase_measure_closure0: {
    "^": "Closure;this_1",
    call$0: function() {
      this.this_1.exercise$0();
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  ListIterator: {
    "^": "Object;__internal$_iterable,__internal$_length,__internal$_index,__internal$_current",
    get$current: function() {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t1, $length, t2;
      t1 = this.__internal$_iterable;
      $length = J.get$length$asx(t1);
      if (this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = this.__internal$_index;
      if (t2 >= $length) {
        this.__internal$_current = null;
        return false;
      }
      if (t2 < 0 || t2 >= t1.length)
        return H.ioore(t1, t2);
      this.__internal$_current = t1[t2];
      ++this.__internal$_index;
      return true;
    }
  },
  FixedLengthListMixin: {
    "^": "Object;"
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = new P.StringBuffer(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = buffer;
    t1._contents = t1.get$_contents() + rightDelimiter;
    t1 = buffer.get$_contents();
    return t1.charCodeAt(0) == 0 ? t1 : t1;
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i)
      if (o === t1[i])
        return true;
    return false;
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, this.get$length(receiver), 0, null);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    $isList: 1,
    $asList: null
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  Error_safeToString: function(object) {
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string")
      return JSON.stringify(object);
    return H.Primitives_objectToString(object);
  },
  bool: {
    "^": "Object;",
    toString$0: function(_) {
      return this ? "true" : "false";
    }
  },
  "+bool": 0,
  $double: {
    "^": "num;"
  },
  "+double": 0,
  Error: {
    "^": "Object;"
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;_hasValue,invalidValue,name,message",
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var t1, message, prefix, explanation, errorValue;
      t1 = this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = this.get$_errorName() + message;
      if (!this._hasValue)
        return prefix;
      explanation = this.get$_errorExplanation();
      errorValue = P.Error_safeToString(this.invalidValue);
      return prefix + explanation + ": " + H.S(errorValue);
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(false, null, null, message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;start,end,_hasValue,invalidValue,name,message",
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var t1, explanation, t2;
      t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else {
          if (typeof t2 !== "number")
            return t2.$gt();
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (t2 > t1)
            explanation = ": Not in range " + t1 + ".." + t2 + ", inclusive";
          else
            explanation = t2 < t1 ? ": Valid value range is empty" : ": Only valid value is " + t1;
        }
      }
      return explanation;
    },
    static: {RangeError$value: function(value, $name, message) {
        return new P.RangeError(null, null, true, value, $name, "Value not in range");
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(this.modifiedObject)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    }
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      return "Exception: " + this.message;
    }
  },
  $int: {
    "^": "num;"
  },
  "+int": 0,
  List: {
    "^": "Object;",
    $asList: null
  },
  "+List": 0,
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;"
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Stopwatch: {
    "^": "Object;_start,_stop",
    start$0: function() {
      var t1, t2;
      t1 = this._start == null;
      if (!t1 && true)
        return;
      t2 = $.Primitives_timerTicks;
      if (t1)
        this._start = t2.call$0();
      else {
        this._start = J.$sub$n(t2.call$0(), C.JSNull_methods.$sub(this._stop, this._start));
        this._stop = null;
      }
    },
    get$elapsedTicks: function() {
      if (this._start == null)
        return 0;
      return J.$sub$n($.Primitives_timerTicks.call$0(), this._start);
    }
  },
  String: {
    "^": "Object;"
  },
  "+String": 0,
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    writeAll$2: function(objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do
          this._contents += H.S(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        this._contents += H.S(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          this._contents += H.S(iterator.get$current());
        }
      }
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  max: function(a, b) {
    var t1;
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return a + b;
      if (isNaN(b))
        return b;
      return a;
    }
    if (b === 0)
      t1 = a === 0 ? 1 / a < 0 : a < 0;
    else
      t1 = false;
    if (t1)
      return b;
    return a;
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  NativeTypedData: {
    "^": "Interceptor;",
    "%": ";ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble"
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $isJavaScriptIndexingBehavior: 1
  },
  NativeTypedArrayOfDouble: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;"
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: 1,
    $asList: function() {
      return [P.$double];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  },
  NativeFloat32List: {
    "^": "NativeTypedArrayOfDouble;",
    $isList: 1,
    $asList: function() {
      return [P.$double];
    },
    "%": "Float32Array"
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["ray_trace", "default/renderscene.dart", , D, {
  "^": "",
  renderScene: function($event) {
    var scene, t1, raytracer;
    scene = new D.Scene(null, null, null, null);
    scene.Scene$0();
    scene.camera = D.Camera$(C.Vector_0_0_m15, C.Vector_idk, C.Vector_0_1_0);
    scene.background = C.Background_waU;
    t1 = new D.Vector(0.1, 0.9, -0.5).normalize$0();
    scene.shapes.push(new D.Plane(1.2, t1, C.Chessboard_s8k));
    scene.shapes.push(C.Sphere_44Q);
    scene.shapes.push(C.Sphere_gsm);
    scene.lights.push(C.Light_ia3);
    scene.lights.push(C.Light_yrN);
    raytracer = new D.Engine(100, 100, 5, 5, true, true, true, true, 2, null);
    raytracer.canvasHeight = 20;
    raytracer.canvasWidth = 20;
    raytracer.renderScene$2(scene, null);
  },
  Color: {
    "^": "Object;red<,green,blue",
    limit$0: function() {
      var t1, r, g, b;
      t1 = this.red;
      if (t1 > 0)
        r = t1 > 1 ? 1 : t1;
      else
        r = 0;
      t1 = this.green;
      if (t1 > 0)
        g = t1 > 1 ? 1 : t1;
      else
        g = 0;
      t1 = this.blue;
      if (t1 > 0)
        b = t1 > 1 ? 1 : t1;
      else
        b = 0;
      return new D.Color(r, g, b);
    },
    $add: function(_, c2) {
      return new D.Color(this.red + c2.get$red(), this.green + c2.green, this.blue + c2.blue);
    },
    toString$0: function(_) {
      var r, g, b;
      r = C.JSNumber_methods.toInt$0(this.red * 255);
      g = C.JSNumber_methods.toInt$0(this.green * 255);
      b = C.JSNumber_methods.toInt$0(this.blue * 255);
      return "rgb(" + r + "," + g + "," + b + ")";
    }
  },
  IntersectionInfo: {
    "^": "Object;isHit,hitCount,shape,position,normal,color,distance",
    toString$0: function(_) {
      return "Intersection [" + J.toString$0(this.position) + "]";
    }
  },
  Engine: {
    "^": "Object;canvasWidth,canvasHeight,pixelWidth,pixelHeight,renderDiffuse,renderShadows,renderHighlights,renderReflections,rayDepth,canvas",
    renderScene$2: function(scene, canvas) {
      var canvasHeight, canvasWidth, y, yp, x, xp, t1, t2, t3, t4, t5, t6, m;
      $.checkNumber = 0;
      this.canvas = null;
      canvasHeight = this.canvasHeight;
      canvasWidth = this.canvasWidth;
      if (typeof canvasHeight !== "number")
        return H.iae(canvasHeight);
      y = 0;
      for (; y < canvasHeight; ++y) {
        if (typeof canvasWidth !== "number")
          return H.iae(canvasWidth);
        yp = y / canvasHeight * 2 - 1;
        x = 0;
        for (; x < canvasWidth; ++x) {
          xp = x / canvasWidth * 2 - 1;
          t1 = scene.camera;
          t2 = t1.screen;
          t3 = t1.equator;
          t4 = t1.up;
          t5 = t2.x - (t3.x * xp - t4.x * yp);
          t6 = t2.z - (t3.z * xp - t4.z * yp);
          t4 = -(t2.y - (t3.y * xp - t4.y * yp));
          t1 = t1.position;
          t3 = t5 - t1.x;
          t2 = t4 - t1.y;
          t1 = t6 - t1.z;
          m = Math.sqrt(t3 * t3 + t2 * t2 + t1 * t1);
          t1 = this.getPixelColor$2(new D.Ray(new D.Vector(t5, t4, t6), new D.Vector(t3 / m, t2 / m, t1 / m)), scene);
          t2 = $.checkNumber;
          t1 = C.JSInt_methods._shrOtherPositive$1(C.JSNumber_methods.toInt$0(t1.red * 255) * 77 + C.JSNumber_methods.toInt$0(t1.green * 255) * 150 + C.JSNumber_methods.toInt$0(t1.blue * 255) * 29, 8);
          if (typeof t2 !== "number")
            return t2.$add();
          $.checkNumber = t2 + t1;
        }
      }
      if ($.checkNumber !== 55545)
        throw H.wrapException("Scene rendered incorrectly");
    },
    getPixelColor$2: function(ray, scene) {
      var info = this.testIntersection$3(ray, scene, null);
      if (info.isHit)
        return this.rayTrace$4(info, ray, scene, 0);
      return scene.background.color;
    },
    testIntersection$3: function(ray, scene, exclude) {
      var best, hits, i, t1, shape, info, t2;
      best = new D.IntersectionInfo(false, 0, null, null, null, null, null);
      best.color = C.Color_0_0_0;
      best.distance = 2000;
      for (hits = 0, i = 0; t1 = scene.shapes, i < t1.length; ++i) {
        shape = t1[i];
        if (shape !== exclude) {
          info = shape.intersect$1(ray);
          if (info.isHit) {
            t1 = info.distance;
            if (typeof t1 !== "number")
              return t1.$ge();
            if (t1 >= 0) {
              t2 = best.distance;
              if (typeof t2 !== "number")
                return H.iae(t2);
              t2 = t1 < t2;
              t1 = t2;
            } else
              t1 = false;
          } else
            t1 = false;
          if (t1) {
            ++hits;
            best = info;
          }
        }
      }
      best.hitCount = hits;
      return best;
    },
    rayTrace$4: function(info, ray, scene, depth) {
      var t1, t2, result, shininess, t3, t4, t5, t6, t7, t8, t9, color, i, t10, light, t11, t12, t13, t14, t15, m, t16, $L, t17, t18, t19, t20, reflectionRay, refl, shadowInfo, dB, m0, glossWeight;
      t1 = info.color;
      t2 = scene.background.ambience;
      result = new D.Color(t1.red * t2, t1.green * t2, t1.blue * t2);
      t2 = info.shape.material;
      shininess = Math.pow(10, t2.gloss + 1);
      for (t1 = this.renderHighlights, t2 = this.renderShadows, t3 = depth <= this.rayDepth, t4 = this.renderDiffuse, t5 = this.renderReflections, t6 = ray.direction, t7 = t6.x, t8 = t6.y, t6 = t6.z, t9 = depth + 1, color = result, i = 0; t10 = scene.lights, i < t10.length; ++i) {
        light = t10[i];
        t10 = light.position;
        t11 = info.position;
        t12 = t10.x;
        t13 = t12 - t11.x;
        t14 = t10.y;
        t15 = t14 - t11.y;
        t10 = t10.z;
        t11 = t10 - t11.z;
        m = Math.sqrt(t13 * t13 + t15 * t15 + t11 * t11);
        t13 /= m;
        t15 /= m;
        t11 /= m;
        if (t4) {
          t16 = info.normal;
          $L = t13 * t16.x + t15 * t16.y + t11 * t16.z;
          if ($L > 0) {
            t16 = info.color;
            t17 = light.color;
            color = new D.Color(color.red + t16.red * (t17.red * $L), color.green + t16.green * (t17.green * $L), color.blue + t16.blue * (t17.blue * $L));
          }
        }
        if (t3)
          if (t5 && info.shape.material.reflection > 0) {
            t16 = info.position;
            t17 = info.normal;
            t18 = t17.x;
            t19 = t17.y;
            t17 = t17.z;
            t20 = 2 * -(t18 * t7 + t19 * t8 + t17 * t6);
            reflectionRay = new D.Ray(t16, new D.Vector(t7 + t18 * t20, t8 + t19 * t20, t6 + t17 * t20));
            refl = this.testIntersection$3(reflectionRay, scene, info.shape);
            if (refl.isHit) {
              t16 = refl.distance;
              if (typeof t16 !== "number")
                return t16.$gt();
              t16 = t16 > 0;
            } else
              t16 = false;
            if (t16) {
              t16 = this.rayTrace$4(refl, reflectionRay, scene, t9);
              refl.color = t16;
            } else {
              t16 = scene.background.color;
              refl.color = t16;
            }
            t17 = info.shape.material.reflection;
            t18 = 1 - t17;
            result = new D.Color(color.red * t18 + t16.red * t17, color.green * t18 + t16.green * t17, color.blue * t18 + t16.blue * t17);
            color = result;
          }
        shadowInfo = new D.IntersectionInfo(false, 0, null, null, null, null, null);
        shadowInfo.color = C.Color_0_0_0;
        if (t2) {
          shadowInfo = this.testIntersection$3(new D.Ray(info.position, new D.Vector(t13, t15, t11)), scene, info.shape);
          if (shadowInfo.isHit) {
            t11 = shadowInfo.shape;
            t13 = info.shape;
            t13 = t11 == null ? t13 != null : t11 !== t13;
            t11 = t13;
          } else
            t11 = false;
          if (t11) {
            t11 = shadowInfo.shape.material;
            dB = 0.5 * Math.pow(t11.transparency, 0.5);
            result = new D.Color(color.red * 0.5 + dB, color.green * 0.5 + dB, color.blue * 0.5 + dB);
            result.limit$0();
            color = result;
          }
        }
        if (t1 && !shadowInfo.isHit && info.shape.material.gloss > 0) {
          t11 = info.shape.position;
          t12 = t11.x - t12;
          t14 = t11.y - t14;
          t10 = t11.z - t10;
          m = Math.sqrt(t12 * t12 + t14 * t14 + t10 * t10);
          t11 = scene.camera.position;
          t13 = info.shape.position;
          t15 = t11.x - t13.x;
          t16 = t11.y - t13.y;
          t13 = t11.z - t13.z;
          m0 = Math.sqrt(t15 * t15 + t16 * t16 + t13 * t13);
          t11 = t15 / m0 - t12 / m;
          t14 = t16 / m0 - t14 / m;
          t10 = t13 / m0 - t10 / m;
          m = Math.sqrt(t11 * t11 + t14 * t14 + t10 * t10);
          t12 = info.normal;
          t10 = P.max(t12.x * (t11 / m) + t12.y * (t14 / m) + t12.z * (t10 / m), 0);
          glossWeight = Math.pow(t10, shininess);
          t10 = light.color;
          color = new D.Color(t10.red * glossWeight + color.red, t10.green * glossWeight + color.green, t10.blue * glossWeight + color.blue);
        }
      }
      return color.limit$0();
    },
    toString$0: function(_) {
      return "Engine [canvasWidth: " + H.S(this.canvasWidth) + ", canvasHeight: " + H.S(this.canvasHeight) + "]";
    }
  },
  Materials: {
    "^": "Object;",
    wrapUp$1: function(t) {
      t = C.JSNumber_methods.$mod(t, 2);
      if (t < -1)
        t += 2;
      return t >= 1 ? t - 2 : t;
    }
  },
  Chessboard: {
    "^": "Materials;colorEven,colorOdd,density,gloss,transparency,reflection,refraction,hasTexture",
    getColor$2: function(u, v) {
      var t1 = this.density;
      if (this.wrapUp$1(u * t1) * this.wrapUp$1(v * t1) < 0)
        return this.colorEven;
      else
        return this.colorOdd;
    }
  },
  Solid: {
    "^": "Materials;color,gloss,transparency,reflection,refraction,hasTexture",
    getColor$2: function(u, v) {
      return this.color;
    }
  },
  Light: {
    "^": "Object;position,color,intensity"
  },
  Ray: {
    "^": "Object;position,direction",
    toString$0: function(_) {
      var t1 = this.direction;
      return "Ray [" + J.toString$0(this.position) + ", " + ("Vector [" + H.S(t1.x) + ", " + H.S(t1.y) + " ," + H.S(t1.z) + " ]") + "]";
    }
  },
  Camera: {
    "^": "Object;position,lookAt,up,equator,screen",
    toString$0: function(_) {
      return "Camera []";
    },
    Camera$3: function(position, lookAt, up) {
      var t1 = this.lookAt;
      this.equator = t1.normalize$0().cross$1(this.up);
      this.screen = this.position.$add(0, t1);
    },
    static: {Camera$: function(position, lookAt, up) {
        var t1 = new D.Camera(position, lookAt, up, null, null);
        t1.Camera$3(position, lookAt, up);
        return t1;
      }}
  },
  Background: {
    "^": "Object;color,ambience"
  },
  Scene: {
    "^": "Object;camera,shapes,lights,background",
    Scene$0: function() {
      this.camera = D.Camera$(C.Vector_XjV, C.Vector_0_0_1, C.Vector_0_1_0);
      this.shapes = [];
      this.lights = [];
      this.background = C.Background_mKK;
    }
  },
  BaseShape: {
    "^": "Object;",
    toString$0: function(_) {
      return "BaseShape";
    }
  },
  Plane: {
    "^": "BaseShape;d,position,material",
    intersect$1: function(ray) {
      var info, t1, t2, Vd, t3, t, vU, vV;
      info = new D.IntersectionInfo(false, 0, null, null, null, null, null);
      info.color = C.Color_0_0_0;
      t1 = this.position;
      t2 = ray.direction;
      Vd = t1.dot$1(t2);
      if (Vd === 0)
        return info;
      t3 = ray.position;
      t = -(t1.dot$1(t3) + this.d) / Vd;
      if (t <= 0)
        return info;
      info.shape = this;
      info.isHit = true;
      t2 = t3.$add(0, t2.multiplyScalar$1(t));
      info.position = t2;
      info.normal = t1;
      info.distance = t;
      t3 = this.material;
      if (t3.hasTexture) {
        vU = new D.Vector(t1.y, t1.z, -t1.x);
        vV = vU.cross$1(t1);
        info.color = t3.getColor$2(t2.dot$1(vU), t2.dot$1(vV));
      } else
        info.color = t3.getColor$2(0, 0);
      return info;
    },
    toString$0: function(_) {
      var t1 = this.position;
      return "Plane [" + ("Vector [" + H.S(t1.x) + ", " + H.S(t1.y) + " ," + H.S(t1.z) + " ]") + ", d=" + H.S(this.d) + "]";
    }
  },
  Sphere: {
    "^": "BaseShape;radius,position,material",
    intersect$1: function(ray) {
      var info, t1, t2, dst, t3, $B, t4, $D;
      info = new D.IntersectionInfo(false, 0, null, null, null, null, null);
      info.color = C.Color_0_0_0;
      info.shape = this;
      t1 = ray.position;
      t2 = this.position;
      dst = t1.$sub(0, t2);
      t3 = ray.direction;
      $B = dst.dot$1(t3);
      t4 = this.radius;
      $D = $B * $B - (dst.dot$1(dst) - t4 * t4);
      if ($D > 0) {
        info.isHit = true;
        t4 = -$B - Math.sqrt(H.checkNum($D));
        info.distance = t4;
        t4 = t1.$add(0, t3.multiplyScalar$1(t4));
        info.position = t4;
        info.normal = t4.$sub(0, t2).normalize$0();
        info.color = this.material.getColor$2(0, 0);
      } else
        info.isHit = false;
      return info;
    },
    toString$0: function(_) {
      var t1 = this.position;
      return "Sphere [position=" + ("Vector [" + H.S(t1.x) + ", " + H.S(t1.y) + " ," + H.S(t1.z) + " ]") + ", radius=" + H.S(this.radius) + "]";
    }
  },
  Vector: {
    "^": "Object;x<,y<,z<",
    normalize$0: function() {
      var t1, t2, t3, m;
      t1 = this.x;
      t2 = this.y;
      t3 = this.z;
      m = Math.sqrt(H.checkNum(t1 * t1 + t2 * t2 + t3 * t3));
      return new D.Vector(t1 / m, t2 / m, t3 / m);
    },
    cross$1: function(w) {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.z;
      t2 = w.y;
      t3 = this.y;
      t4 = w.z;
      t5 = w.x;
      t6 = this.x;
      return new D.Vector(-t1 * t2 + t3 * t4, t1 * t5 - t6 * t4, -t3 * t5 + t6 * t2);
    },
    dot$1: function(w) {
      return this.x * w.x + this.y * w.y + this.z * w.z;
    },
    $add: function(_, w) {
      return new D.Vector(w.get$x() + this.x, w.y + this.y, w.z + this.z);
    },
    $sub: function(_, w) {
      return new D.Vector(this.x - w.get$x(), this.y - w.get$y(), this.z - w.get$z());
    },
    $mul: function(_, w) {
      return new D.Vector(C.JSNumber_methods.$mul(this.x, w.get$x()), C.JSNumber_methods.$mul(this.y, w.get$y()), C.JSNumber_methods.$mul(this.z, w.get$z()));
    },
    multiplyScalar$1: function(w) {
      if (typeof w !== "number")
        return H.iae(w);
      return new D.Vector(this.x * w, this.y * w, this.z * w);
    },
    toString$0: function(_) {
      return "Vector [" + H.S(this.x) + ", " + H.S(this.y) + " ," + H.S(this.z) + " ]";
    }
  }
}],
];
parseReflectionData(dart);
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$mul$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver * a0;
  return J.getInterceptor$ns(receiver).$mul(receiver, a0);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.Color_EuX = new D.Color(0, 0, 0.5);
C.Background_mKK = new D.Background(C.Color_EuX, 0.2);
C.Color_EuX0 = new D.Color(0.5, 0.5, 0.5);
C.Background_waU = new D.Background(C.Color_EuX0, 0.4);
C.Color_1_1_1 = new D.Color(1, 1, 1);
C.Color_0_0_0 = new D.Color(0, 0, 0);
C.Chessboard_s8k = new D.Chessboard(C.Color_1_1_1, C.Color_0_0_0, 0.7, 1, 0, 0.2, 0.5, true);
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_gkc = function() {
  function typeNameInChrome(o) {
    var constructor = o.constructor;
    if (constructor) {
      var name = constructor.name;
      if (name) return name;
    }
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_gkc0 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
C.Vector_5_10_m1 = new D.Vector(5, 10, -1);
C.Color_LKl = new D.Color(0.8, 0.8, 0.8);
C.Light_ia3 = new D.Light(C.Vector_5_10_m1, C.Color_LKl, 10);
C.Vector_m3_5_m15 = new D.Vector(-3, 5, -15);
C.Light_yrN = new D.Light(C.Vector_m3_5_m15, C.Color_LKl, 100);
C.Vector_2nP = new D.Vector(-1.5, 1.5, 2);
C.Color_EuX1 = new D.Color(0, 0.5, 0.5);
C.Solid_AKg = new D.Solid(C.Color_EuX1, 2, 0, 0.3, 0, false);
C.Sphere_44Q = new D.Sphere(1.5, C.Vector_2nP, C.Solid_AKg);
C.Vector_rxi = new D.Vector(1, 0.25, 1);
C.Color_Fcu = new D.Color(0.9, 0.9, 0.9);
C.Solid_eNU = new D.Solid(C.Color_Fcu, 1.5, 0, 0.1, 0, false);
C.Sphere_gsm = new D.Sphere(0.5, C.Vector_rxi, C.Solid_eNU);
C.Vector_0_0_1 = new D.Vector(0, 0, 1);
C.Vector_0_0_m15 = new D.Vector(0, 0, -15);
C.Vector_0_1_0 = new D.Vector(0, 1, 0);
C.Vector_XjV = new D.Vector(0, 0, -0.5);
C.Vector_idk = new D.Vector(-0.2, 0, 5);
{
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    $dart_deferred_initializers[hunkHash](globalsHolder, $);
    init.deferredInitialized[hunkHash] = true;
  };
}
init.deferredLibraryUris = {};
init.deferredLibraryHashes = {};
$.Primitives_timerFrequency = null;
$.Primitives_timerTicks = null;
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.printToZone = null;
$.Stopwatch__frequency = null;
$.checkNumber = null;
$.checkNumber0 = null;
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});

init.metadata = [{func: "num_", ret: P.num},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = Object.create(null);
  init.allClasses = Object.create(null);
  init.getTypeFromName = function(name) {
    return init.allClasses[name];
  };
  init.interceptorsByTag = Object.create(null);
  init.leafTags = Object.create(null);
  init.finishedClasses = Object.create(null);
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    if (!init.lazies)
      init.lazies = Object.create(null);
    init.lazies[fieldName] = getterName;
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              $[fieldName] = null;
          }
        } else
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var staticNames = Object.keys(isolateProperties);
      for (var i = 0; i < staticNames.length; i++) {
        var staticName = staticNames[i];
        this[staticName] = isolateProperties[staticName];
      }
      var lazies = init.lazies;
      var lazyInitializers = lazies ? Object.keys(lazies) : [];
      for (var i = 0; i < lazyInitializers.length; i++)
        this[lazies[lazyInitializers[i]]] = null;
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
      for (var i = 0; i < lazyInitializers.length; i++) {
        var lazyInitName = lazies[lazyInitializers[i]];
        this[lazyInitName] = isolateProperties[lazyInitName];
      }
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    return Isolate;
  };
}
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
  init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
}();
;// BEGIN invoke [main].
(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].removeEventListener("load", onLoad, false);
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i)
    scripts[i].addEventListener("load", onLoad, false);
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function")
    dartMainRunner(D.main, []);
  else
    D.main([]);
});
;
// END invoke [main].
})()

//# sourceMappingURL=Tracer.dart.js.map
